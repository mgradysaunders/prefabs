<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>preform: Color</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<!--Broken...-->
<!--<script type="text/javascript" src="dynsections.js"></script>-->
<!--Load MathJax manually...-->
<!--cdn.mathjax.org shutting down April 30th, 2019
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
MathJax.Hub.Config({
  displayAlign: "left",
  displayIndent: "2em",
  TeX: {
    Macros: {
        real: ["\\operatorname{Re}"],
        imag: ["\\operatorname{Im}"],
        dual: ["\\operatorname{Du}"],
        symm: ["\\operatorname{Symm}"],
        skew: ["\\operatorname{Skew}"],
        erf: ["\\operatorname{erf}"],
        erfc: ["\\operatorname{erfc}"],
        normalize: ["\\operatorname{normalize}"],
        argmin: ["\\operatorname{argmin}"],
        argmax: ["\\operatorname{argmax}"]
    }
  }
});
</script>
<script type="text/javascript" src="DoxygenFix.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">preform
   </div>
   <div id="projectbrief">Header-only utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Color</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga09c109ef2e17c54f12210b6f7c805905"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">pr::composite_mode</a> : int { <br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a25d902c24283ab8cfbac54dfa101ad31">pr::composite_mode::src</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a28e3d688a3c077b887921cea3fb1dbc7">pr::composite_mode::dst</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a98edf09a82f9f7d372c0f5ad3b086f2d">pr::composite_mode::src_over</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a1aba18694a6040ab91044bbdf194f3c3">pr::composite_mode::dst_over</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a09d4f8c30829f2fd90bf48afb352dc92">pr::composite_mode::src_in</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a1fc9c7e6c1b69fa138325c4ea088ae43">pr::composite_mode::dst_in</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a6409e48dcc68d7569afc7e580482e090">pr::composite_mode::src_out</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905ac3930745a6db9c3173280dad04568b26">pr::composite_mode::dst_out</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a1a9af792f978f2350307f7fa85f621ba">pr::composite_mode::src_atop</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a7ba2d1903963e07301ed508575c35e75">pr::composite_mode::dst_atop</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905a0a511bbf6f4a40f19275a0eaf722513f">pr::composite_mode::exclusive_or</a>, 
<br />
&#160;&#160;<a class="el" href="group__color.html#gga09c109ef2e17c54f12210b6f7c805905ad7d18cfb3a0d8293e2f5d94ea30e04d2">pr::composite_mode::plus</a>
<br />
 }<tr class="memdesc:ga09c109ef2e17c54f12210b6f7c805905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite modes.  <a href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga09c109ef2e17c54f12210b6f7c805905"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac8c7ffc6449a317efafbf42fe99a6d72"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#gac8c7ffc6449a317efafbf42fe99a6d72">pr::to_string</a> (<a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">composite_mode</a> mode)</td></tr>
<tr class="memdesc:gac8c7ffc6449a317efafbf42fe99a6d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite mode to string.  <a href="group__color.html#gac8c7ffc6449a317efafbf42fe99a6d72">More...</a><br /></td></tr>
<tr class="separator:gac8c7ffc6449a317efafbf42fe99a6d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Color conversion</h2></td></tr>
<tr class="memitem:ga6fd93c91d0247d84a9955937b54494b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6fd93c91d0247d84a9955937b54494b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga6fd93c91d0247d84a9955937b54494b3">pr::srgbenc</a> (T v)</td></tr>
<tr class="memdesc:ga6fd93c91d0247d84a9955937b54494b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB.  <a href="group__color.html#ga6fd93c91d0247d84a9955937b54494b3">More...</a><br /></td></tr>
<tr class="separator:ga6fd93c91d0247d84a9955937b54494b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b41e8a235cf99e55c075647c9267cfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b41e8a235cf99e55c075647c9267cfa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga7b41e8a235cf99e55c075647c9267cfa">pr::srgbenc</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga7b41e8a235cf99e55c075647c9267cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB.  <a href="group__color.html#ga7b41e8a235cf99e55c075647c9267cfa">More...</a><br /></td></tr>
<tr class="separator:ga7b41e8a235cf99e55c075647c9267cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ec9969d08b8213278bcde8b35e7bbb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga99ec9969d08b8213278bcde8b35e7bbb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga99ec9969d08b8213278bcde8b35e7bbb">pr::srgbenc</a> (const multi&lt; T, 4 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga99ec9969d08b8213278bcde8b35e7bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB.  <a href="group__color.html#ga99ec9969d08b8213278bcde8b35e7bbb">More...</a><br /></td></tr>
<tr class="separator:ga99ec9969d08b8213278bcde8b35e7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b69651e661aa1f4953f170b10baabd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga14b69651e661aa1f4953f170b10baabd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga14b69651e661aa1f4953f170b10baabd">pr::srgbdec</a> (T v)</td></tr>
<tr class="memdesc:ga14b69651e661aa1f4953f170b10baabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode linear RGB from sRGB.  <a href="group__color.html#ga14b69651e661aa1f4953f170b10baabd">More...</a><br /></td></tr>
<tr class="separator:ga14b69651e661aa1f4953f170b10baabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a3c63881e9fc3ae4735f765d06f500"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac1a3c63881e9fc3ae4735f765d06f500"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gac1a3c63881e9fc3ae4735f765d06f500">pr::srgbdec</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:gac1a3c63881e9fc3ae4735f765d06f500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode linear RGB from sRGB.  <a href="group__color.html#gac1a3c63881e9fc3ae4735f765d06f500">More...</a><br /></td></tr>
<tr class="separator:gac1a3c63881e9fc3ae4735f765d06f500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b57a4f739fbf8b9a1edb968fafe9e7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b57a4f739fbf8b9a1edb968fafe9e7f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga0b57a4f739fbf8b9a1edb968fafe9e7f">pr::srgbdec</a> (const multi&lt; T, 4 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga0b57a4f739fbf8b9a1edb968fafe9e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode linear RGB from sRGB.  <a href="group__color.html#ga0b57a4f739fbf8b9a1edb968fafe9e7f">More...</a><br /></td></tr>
<tr class="separator:ga0b57a4f739fbf8b9a1edb968fafe9e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87207c33fd0f97fe4be691fdfd7a5794"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga87207c33fd0f97fe4be691fdfd7a5794"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga87207c33fd0f97fe4be691fdfd7a5794">pr::srgenc_hable</a> (T v)</td></tr>
<tr class="memdesc:ga87207c33fd0f97fe4be691fdfd7a5794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB with Hable tonemapping.  <a href="group__color.html#ga87207c33fd0f97fe4be691fdfd7a5794">More...</a><br /></td></tr>
<tr class="separator:ga87207c33fd0f97fe4be691fdfd7a5794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbd102f61722f5dd4d51dec96344516"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafdbd102f61722f5dd4d51dec96344516"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gafdbd102f61722f5dd4d51dec96344516">pr::srgbenc_hable</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:gafdbd102f61722f5dd4d51dec96344516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB with Hable tonemapping.  <a href="group__color.html#gafdbd102f61722f5dd4d51dec96344516">More...</a><br /></td></tr>
<tr class="separator:gafdbd102f61722f5dd4d51dec96344516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804a63d68dd03085d2606477b6783e3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga804a63d68dd03085d2606477b6783e3f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; T, 4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga804a63d68dd03085d2606477b6783e3f">pr::srgbenc_hable</a> (const multi&lt; T, 4 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga804a63d68dd03085d2606477b6783e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB with Hable tonemapping.  <a href="group__color.html#ga804a63d68dd03085d2606477b6783e3f">More...</a><br /></td></tr>
<tr class="separator:ga804a63d68dd03085d2606477b6783e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ead7c347597d328232539849fe1cc60"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3ead7c347597d328232539849fe1cc60"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga3ead7c347597d328232539849fe1cc60">pr::srgbenc_hejl_burgess</a> (T v)</td></tr>
<tr class="memdesc:ga3ead7c347597d328232539849fe1cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB with Hejl/Burgess-Dawson tonemapping.  <a href="group__color.html#ga3ead7c347597d328232539849fe1cc60">More...</a><br /></td></tr>
<tr class="separator:ga3ead7c347597d328232539849fe1cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a23fe2ecde5ac27c733d4b14c1ce5f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9a23fe2ecde5ac27c733d4b14c1ce5f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga9a23fe2ecde5ac27c733d4b14c1ce5f8">pr::srgbenc_hejl_burgess</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga9a23fe2ecde5ac27c733d4b14c1ce5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB with Hejl/Burgess-Dawson tonemapping.  <a href="group__color.html#ga9a23fe2ecde5ac27c733d4b14c1ce5f8">More...</a><br /></td></tr>
<tr class="separator:ga9a23fe2ecde5ac27c733d4b14c1ce5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e74ba174cda38e397ed51d80b4f43d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e74ba174cda38e397ed51d80b4f43d4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; T, 4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga3e74ba174cda38e397ed51d80b4f43d4">pr::srgbenc_hejl_burgess</a> (const multi&lt; T, 4 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga3e74ba174cda38e397ed51d80b4f43d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode linear RGB as sRGB with Hejl/Burgess-Dawson tonemapping.  <a href="group__color.html#ga3e74ba174cda38e397ed51d80b4f43d4">More...</a><br /></td></tr>
<tr class="separator:ga3e74ba174cda38e397ed51d80b4f43d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0594859191efad40acebcde02935a74d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0594859191efad40acebcde02935a74d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga0594859191efad40acebcde02935a74d">pr::wymanx</a> (T lambda)</td></tr>
<tr class="memdesc:ga0594859191efad40acebcde02935a74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit of CIE 1931 X by Wyman et. al.  <a href="group__color.html#ga0594859191efad40acebcde02935a74d">More...</a><br /></td></tr>
<tr class="separator:ga0594859191efad40acebcde02935a74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f9c3e985140538310bbff58f34c964"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga18f9c3e985140538310bbff58f34c964"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga18f9c3e985140538310bbff58f34c964">pr::wymany</a> (T lambda)</td></tr>
<tr class="memdesc:ga18f9c3e985140538310bbff58f34c964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit of CIE 1931 Y by Wyman et. al.  <a href="group__color.html#ga18f9c3e985140538310bbff58f34c964">More...</a><br /></td></tr>
<tr class="separator:ga18f9c3e985140538310bbff58f34c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21180a1a0b538a534b30f90a09cd2d81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21180a1a0b538a534b30f90a09cd2d81"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga21180a1a0b538a534b30f90a09cd2d81">pr::wymanz</a> (T lambda)</td></tr>
<tr class="memdesc:ga21180a1a0b538a534b30f90a09cd2d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit of CIE 1931 Z by Wyman et. al.  <a href="group__color.html#ga21180a1a0b538a534b30f90a09cd2d81">More...</a><br /></td></tr>
<tr class="separator:ga21180a1a0b538a534b30f90a09cd2d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935d39309a1cf80227c06e94f7cab8ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga935d39309a1cf80227c06e94f7cab8ac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga935d39309a1cf80227c06e94f7cab8ac">pr::planck</a> (T t, T lambda)</td></tr>
<tr class="memdesc:ga935d39309a1cf80227c06e94f7cab8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Planck's law.  <a href="group__color.html#ga935d39309a1cf80227c06e94f7cab8ac">More...</a><br /></td></tr>
<tr class="separator:ga935d39309a1cf80227c06e94f7cab8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16fb0557f89adecff79f82d6b24d368f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga16fb0557f89adecff79f82d6b24d368f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga16fb0557f89adecff79f82d6b24d368f">pr::xyztorgb</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga16fb0557f89adecff79f82d6b24d368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">XYZ triple to RGB triple.  <a href="group__color.html#ga16fb0557f89adecff79f82d6b24d368f">More...</a><br /></td></tr>
<tr class="separator:ga16fb0557f89adecff79f82d6b24d368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b50f493f77b11fecb8860e1d73f351"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga73b50f493f77b11fecb8860e1d73f351"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga73b50f493f77b11fecb8860e1d73f351">pr::rgbtoxyz</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga73b50f493f77b11fecb8860e1d73f351"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB triple to XYZ triple.  <a href="group__color.html#ga73b50f493f77b11fecb8860e1d73f351">More...</a><br /></td></tr>
<tr class="separator:ga73b50f493f77b11fecb8860e1d73f351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bb6816b92a84fb48fcfcc00b60a598"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga78bb6816b92a84fb48fcfcc00b60a598"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga78bb6816b92a84fb48fcfcc00b60a598">pr::rgbtoxyz</a> (const multi&lt; T, 2 &gt; &amp;cr, const multi&lt; T, 2 &gt; &amp;cg, const multi&lt; T, 2 &gt; &amp;cb, const multi&lt; T, 3 &gt; &amp;w)</td></tr>
<tr class="memdesc:ga78bb6816b92a84fb48fcfcc00b60a598"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB to XYZ conversion matrix.  <a href="group__color.html#ga78bb6816b92a84fb48fcfcc00b60a598">More...</a><br /></td></tr>
<tr class="separator:ga78bb6816b92a84fb48fcfcc00b60a598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49beaf7bd690269c1b2f360e679e479"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae49beaf7bd690269c1b2f360e679e479"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gae49beaf7bd690269c1b2f360e679e479">pr::xyztolab</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:gae49beaf7bd690269c1b2f360e679e479"><td class="mdescLeft">&#160;</td><td class="mdescRight">XYZ triple to Lab triple.  <a href="group__color.html#gae49beaf7bd690269c1b2f360e679e479">More...</a><br /></td></tr>
<tr class="separator:gae49beaf7bd690269c1b2f360e679e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ea7e7ab04b535c4e8c361fdf37bfed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga09ea7e7ab04b535c4e8c361fdf37bfed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, 3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga09ea7e7ab04b535c4e8c361fdf37bfed">pr::labtoxyz</a> (const multi&lt; T, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ga09ea7e7ab04b535c4e8c361fdf37bfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lab triple to XYZ triple.  <a href="group__color.html#ga09ea7e7ab04b535c4e8c361fdf37bfed">More...</a><br /></td></tr>
<tr class="separator:ga09ea7e7ab04b535c4e8c361fdf37bfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Alpha compositing</h2></td></tr>
<tr class="memitem:ga3c3b565c08cd5b2f5f8a2fe20a967f4f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga3c3b565c08cd5b2f5f8a2fe20a967f4f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga3c3b565c08cd5b2f5f8a2fe20a967f4f">pr::premultiply</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ga3c3b565c08cd5b2f5f8a2fe20a967f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Premultiply.  <a href="group__color.html#ga3c3b565c08cd5b2f5f8a2fe20a967f4f">More...</a><br /></td></tr>
<tr class="separator:ga3c3b565c08cd5b2f5f8a2fe20a967f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43316a39287860d63001822fc941bf80"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga43316a39287860d63001822fc941bf80"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga43316a39287860d63001822fc941bf80">pr::unpremultiply</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ga43316a39287860d63001822fc941bf80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpremultiply.  <a href="group__color.html#ga43316a39287860d63001822fc941bf80">More...</a><br /></td></tr>
<tr class="separator:ga43316a39287860d63001822fc941bf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470180292b667ad49c8b4878c96392cb"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga470180292b667ad49c8b4878c96392cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga470180292b667ad49c8b4878c96392cb">pr::composite_premul</a> (<a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">composite_mode</a> mode, const multi&lt; T, N &gt; &amp;vsrc, const multi&lt; T, N &gt; &amp;vdst)</td></tr>
<tr class="memdesc:ga470180292b667ad49c8b4878c96392cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite via Porter-Duff equation (premultiplied).  <a href="group__color.html#ga470180292b667ad49c8b4878c96392cb">More...</a><br /></td></tr>
<tr class="separator:ga470180292b667ad49c8b4878c96392cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432e8791de819ee15c5ad96e8ee2de87"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga432e8791de819ee15c5ad96e8ee2de87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value||std::is_floating_point&lt; T &gt;::value, multi&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga432e8791de819ee15c5ad96e8ee2de87">pr::composite</a> (<a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">composite_mode</a> mode, const multi&lt; T, N &gt; &amp;vsrc, const multi&lt; T, N &gt; &amp;vdst)</td></tr>
<tr class="memdesc:ga432e8791de819ee15c5ad96e8ee2de87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite via Porter-Duff equation.  <a href="group__color.html#ga432e8791de819ee15c5ad96e8ee2de87">More...</a><br /></td></tr>
<tr class="separator:ga432e8791de819ee15c5ad96e8ee2de87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Color packing</h2></td></tr>
<tr class="memitem:ga44549f77aa01311130c1c8686724b4eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga44549f77aa01311130c1c8686724b4eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, std::uint8_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga44549f77aa01311130c1c8686724b4eb">pr::pack_uint8</a> (T v)</td></tr>
<tr class="memdesc:ga44549f77aa01311130c1c8686724b4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::uint8_t&gt;()</code>.  <a href="group__color.html#ga44549f77aa01311130c1c8686724b4eb">More...</a><br /></td></tr>
<tr class="separator:ga44549f77aa01311130c1c8686724b4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8884b5244d17d7423a48636ed70eae7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8884b5244d17d7423a48636ed70eae7a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, std::uint16_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga8884b5244d17d7423a48636ed70eae7a">pr::pack_uint16</a> (T v)</td></tr>
<tr class="memdesc:ga8884b5244d17d7423a48636ed70eae7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::uint16_t&gt;()</code>.  <a href="group__color.html#ga8884b5244d17d7423a48636ed70eae7a">More...</a><br /></td></tr>
<tr class="separator:ga8884b5244d17d7423a48636ed70eae7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0249a0aa7bc20e0165a9930627c80b42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0249a0aa7bc20e0165a9930627c80b42"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, std::uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga0249a0aa7bc20e0165a9930627c80b42">pr::pack_uint32</a> (T v)</td></tr>
<tr class="memdesc:ga0249a0aa7bc20e0165a9930627c80b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::uint32_t&gt;()</code>.  <a href="group__color.html#ga0249a0aa7bc20e0165a9930627c80b42">More...</a><br /></td></tr>
<tr class="separator:ga0249a0aa7bc20e0165a9930627c80b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43b7a37d1e26e90e59fe4597d84178e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae43b7a37d1e26e90e59fe4597d84178e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, std::int8_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gae43b7a37d1e26e90e59fe4597d84178e">pr::pack_int8</a> (T v)</td></tr>
<tr class="memdesc:gae43b7a37d1e26e90e59fe4597d84178e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::int8_t&gt;()</code>.  <a href="group__color.html#gae43b7a37d1e26e90e59fe4597d84178e">More...</a><br /></td></tr>
<tr class="separator:gae43b7a37d1e26e90e59fe4597d84178e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae224fa7230a06c52e7890ebda5168611"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae224fa7230a06c52e7890ebda5168611"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, std::int16_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gae224fa7230a06c52e7890ebda5168611">pr::pack_int16</a> (T v)</td></tr>
<tr class="memdesc:gae224fa7230a06c52e7890ebda5168611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::int16_t&gt;()</code>.  <a href="group__color.html#gae224fa7230a06c52e7890ebda5168611">More...</a><br /></td></tr>
<tr class="separator:gae224fa7230a06c52e7890ebda5168611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68fe358339010ef6a9e9423ce782240b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68fe358339010ef6a9e9423ce782240b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga68fe358339010ef6a9e9423ce782240b">pr::pack_int32</a> (T v)</td></tr>
<tr class="memdesc:ga68fe358339010ef6a9e9423ce782240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::int32_t&gt;()</code>.  <a href="group__color.html#ga68fe358339010ef6a9e9423ce782240b">More...</a><br /></td></tr>
<tr class="separator:ga68fe358339010ef6a9e9423ce782240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0c299f44bd39299924e3612f3bb935"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gabd0c299f44bd39299924e3612f3bb935"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; std::uint8_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gabd0c299f44bd39299924e3612f3bb935">pr::pack_uint8</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:gabd0c299f44bd39299924e3612f3bb935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::uint8_t&gt;()</code>.  <a href="group__color.html#gabd0c299f44bd39299924e3612f3bb935">More...</a><br /></td></tr>
<tr class="separator:gabd0c299f44bd39299924e3612f3bb935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8d4ebed0f796d470e177d8aa768f66"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga9d8d4ebed0f796d470e177d8aa768f66"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; std::uint16_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga9d8d4ebed0f796d470e177d8aa768f66">pr::pack_uint16</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ga9d8d4ebed0f796d470e177d8aa768f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::uint16_t&gt;()</code>.  <a href="group__color.html#ga9d8d4ebed0f796d470e177d8aa768f66">More...</a><br /></td></tr>
<tr class="separator:ga9d8d4ebed0f796d470e177d8aa768f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2944eb274ea9d43f4bbdaa4a61fab3fd"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga2944eb274ea9d43f4bbdaa4a61fab3fd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; std::uint32_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga2944eb274ea9d43f4bbdaa4a61fab3fd">pr::pack_uint32</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ga2944eb274ea9d43f4bbdaa4a61fab3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::uint32_t&gt;()</code>.  <a href="group__color.html#ga2944eb274ea9d43f4bbdaa4a61fab3fd">More...</a><br /></td></tr>
<tr class="separator:ga2944eb274ea9d43f4bbdaa4a61fab3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b191e69c45b944a362c87b3fc080b6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gab1b191e69c45b944a362c87b3fc080b6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; std::int8_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gab1b191e69c45b944a362c87b3fc080b6">pr::pack_int8</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:gab1b191e69c45b944a362c87b3fc080b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::int8_t&gt;()</code>.  <a href="group__color.html#gab1b191e69c45b944a362c87b3fc080b6">More...</a><br /></td></tr>
<tr class="separator:gab1b191e69c45b944a362c87b3fc080b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1382f7905f44b3c97d88ba00112fdaf"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gaa1382f7905f44b3c97d88ba00112fdaf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; std::int16_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gaa1382f7905f44b3c97d88ba00112fdaf">pr::pack_int16</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:gaa1382f7905f44b3c97d88ba00112fdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::int16_t&gt;()</code>.  <a href="group__color.html#gaa1382f7905f44b3c97d88ba00112fdaf">More...</a><br /></td></tr>
<tr class="separator:gaa1382f7905f44b3c97d88ba00112fdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac3d0ee928590110bf9fe3e8518843a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gaaac3d0ee928590110bf9fe3e8518843a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, multi&lt; std::int32_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gaaac3d0ee928590110bf9fe3e8518843a">pr::pack_int32</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:gaaac3d0ee928590110bf9fe3e8518843a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;std::int32_t&gt;()</code>.  <a href="group__color.html#gaaac3d0ee928590110bf9fe3e8518843a">More...</a><br /></td></tr>
<tr class="separator:gaaac3d0ee928590110bf9fe3e8518843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81f5d0c84d97a26cdf11ee30a0d6c5b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga81f5d0c84d97a26cdf11ee30a0d6c5b1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga81f5d0c84d97a26cdf11ee30a0d6c5b1">pr::unpack_float</a> (T v)</td></tr>
<tr class="memdesc:ga81f5d0c84d97a26cdf11ee30a0d6c5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;float&gt;()</code>.  <a href="group__color.html#ga81f5d0c84d97a26cdf11ee30a0d6c5b1">More...</a><br /></td></tr>
<tr class="separator:ga81f5d0c84d97a26cdf11ee30a0d6c5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425531deba1372b278c28860493d72ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga425531deba1372b278c28860493d72ae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga425531deba1372b278c28860493d72ae">pr::unpack_double</a> (T v)</td></tr>
<tr class="memdesc:ga425531deba1372b278c28860493d72ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;double&gt;()</code>.  <a href="group__color.html#ga425531deba1372b278c28860493d72ae">More...</a><br /></td></tr>
<tr class="separator:ga425531deba1372b278c28860493d72ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ff38529455512e68bb681ca9552c66"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga72ff38529455512e68bb681ca9552c66"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, multi&lt; float, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga72ff38529455512e68bb681ca9552c66">pr::unpack_float</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ga72ff38529455512e68bb681ca9552c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;float&gt;()</code>.  <a href="group__color.html#ga72ff38529455512e68bb681ca9552c66">More...</a><br /></td></tr>
<tr class="separator:ga72ff38529455512e68bb681ca9552c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff505b5b2261a82ea8bd2d5311d67a6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gadff505b5b2261a82ea8bd2d5311d67a6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, multi&lt; double, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gadff505b5b2261a82ea8bd2d5311d67a6">pr::unpack_double</a> (const multi&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:gadff505b5b2261a82ea8bd2d5311d67a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>fstretch&lt;double&gt;()</code>.  <a href="group__color.html#gadff505b5b2261a82ea8bd2d5311d67a6">More...</a><br /></td></tr>
<tr class="separator:gadff505b5b2261a82ea8bd2d5311d67a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><code>&lt;preform/color.hpp&gt;</code></p>
<p><b>C++ version</b>: &gt;=C++17 </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga09c109ef2e17c54f12210b6f7c805905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c109ef2e17c54f12210b6f7c805905">&#9670;&nbsp;</a></span>composite_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">pr::composite_mode</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composite modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a25d902c24283ab8cfbac54dfa101ad31"></a>src&#160;</td><td class="fielddoc"><p>Only source. </p>
<ul>
<li>\( f_{\text{src}} = 1 \)</li>
<li>\( f_{\text{dst}} = 0 \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a28e3d688a3c077b887921cea3fb1dbc7"></a>dst&#160;</td><td class="fielddoc"><p>Only destination. </p>
<ul>
<li>\( f_{\text{src}} = 0 \)</li>
<li>\( f_{\text{dst}} = 1 \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a98edf09a82f9f7d372c0f5ad3b086f2d"></a>src_over&#160;</td><td class="fielddoc"><p>Source over destination. </p>
<ul>
<li>\( f_{\text{src}} = 1 \)</li>
<li>\( f_{\text{dst}} = 1 - \alpha_{\text{src}} \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a1aba18694a6040ab91044bbdf194f3c3"></a>dst_over&#160;</td><td class="fielddoc"><p>Destination over source. </p>
<ul>
<li>\( f_{\text{src}} = 1 - \alpha_{\text{dst}} \)</li>
<li>\( f_{\text{dst}} = 1 \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a09d4f8c30829f2fd90bf48afb352dc92"></a>src_in&#160;</td><td class="fielddoc"><p>Source inside destination. </p>
<ul>
<li>\( f_{\text{src}} = \alpha_{\text{dst}} \)</li>
<li>\( f_{\text{dst}} = 0 \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a1fc9c7e6c1b69fa138325c4ea088ae43"></a>dst_in&#160;</td><td class="fielddoc"><p>Destination inside source. </p>
<ul>
<li>\( f_{\text{src}} = 0 \)</li>
<li>\( f_{\text{dst}} = \alpha_{\text{src}} \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a6409e48dcc68d7569afc7e580482e090"></a>src_out&#160;</td><td class="fielddoc"><p>Source outside destination. </p>
<ul>
<li>\( f_{\text{src}} = 1 - \alpha_{\text{dst}} \)</li>
<li>\( f_{\text{dst}} = 0 \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905ac3930745a6db9c3173280dad04568b26"></a>dst_out&#160;</td><td class="fielddoc"><p>Destination outside source. </p>
<ul>
<li>\( f_{\text{src}} = 0 \)</li>
<li>\( f_{\text{dst}} = 1 - \alpha_{\text{src}} \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a1a9af792f978f2350307f7fa85f621ba"></a>src_atop&#160;</td><td class="fielddoc"><p>Source atop destination. </p>
<ul>
<li>\( f_{\text{src}} = \alpha_{\text{dst}} \)</li>
<li>\( f_{\text{dst}} = 1 - \alpha_{\text{src}} \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a7ba2d1903963e07301ed508575c35e75"></a>dst_atop&#160;</td><td class="fielddoc"><p>Destination atop source. </p>
<ul>
<li>\( f_{\text{src}} = 1 - \alpha_{\text{dst}} \)</li>
<li>\( f_{\text{dst}} = \alpha_{\text{src}} \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905a0a511bbf6f4a40f19275a0eaf722513f"></a>exclusive_or&#160;</td><td class="fielddoc"><p>Exclusive or. </p>
<ul>
<li>\( f_{\text{src}} = 1 - \alpha_{\text{dst}} \)</li>
<li>\( f_{\text{dst}} = 1 - \alpha_{\text{src}} \) </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga09c109ef2e17c54f12210b6f7c805905ad7d18cfb3a0d8293e2f5d94ea30e04d2"></a>plus&#160;</td><td class="fielddoc"><p>Plus. </p>
<ul>
<li>\( f_{\text{src}} = 1 \)</li>
<li>\( f_{\text{dst}} = 1 \) </li>
</ul>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6fd93c91d0247d84a9955937b54494b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fd93c91d0247d84a9955937b54494b3">&#9670;&nbsp;</a></span>srgbenc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, T&gt; pr::srgbenc </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB. </p>
<p class="formulaDsp">
\[ \operatorname{srgbenc}(v) = \begin{cases} 12.92 v &amp; v \le 0.0031308 \\ 1.055 v^{1/2.4} - 0.055 &amp; v &gt; 0.0031308 \end{cases} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7b41e8a235cf99e55c075647c9267cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b41e8a235cf99e55c075647c9267cfa">&#9670;&nbsp;</a></span>srgbenc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::srgbenc </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbenc}(r) \\ \operatorname{srgbenc}(g) \\ \operatorname{srgbenc}(b) \end{bmatrix} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga99ec9969d08b8213278bcde8b35e7bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ec9969d08b8213278bcde8b35e7bbb">&#9670;&nbsp;</a></span>srgbenc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 4&gt; &gt; pr::srgbenc </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \\ \alpha&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbenc}(r) \\ \operatorname{srgbenc}(g) \\ \operatorname{srgbenc}(b) \\ \alpha \end{bmatrix} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga14b69651e661aa1f4953f170b10baabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14b69651e661aa1f4953f170b10baabd">&#9670;&nbsp;</a></span>srgbdec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, T&gt; pr::srgbdec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode linear RGB from sRGB. </p>
<p class="formulaDsp">
\[ \operatorname{srgbdec}(v) = \begin{cases} v / 12.92 &amp; v \le 0.04045 \\ ((v + 0.055) / 1.055)^{2.4} &amp; v &gt; 0.04045 \end{cases} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac1a3c63881e9fc3ae4735f765d06f500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a3c63881e9fc3ae4735f765d06f500">&#9670;&nbsp;</a></span>srgbdec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::srgbdec </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode linear RGB from sRGB. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbdec}(r) \\ \operatorname{srgbdec}(g) \\ \operatorname{srgbdec}(b) \end{bmatrix} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0b57a4f739fbf8b9a1edb968fafe9e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b57a4f739fbf8b9a1edb968fafe9e7f">&#9670;&nbsp;</a></span>srgbdec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 4&gt; &gt; pr::srgbdec </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode linear RGB from sRGB. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \\ \alpha&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbdec}(r) \\ \operatorname{srgbdec}(g) \\ \operatorname{srgbdec}(b) \\ \alpha \end{bmatrix} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga87207c33fd0f97fe4be691fdfd7a5794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87207c33fd0f97fe4be691fdfd7a5794">&#9670;&nbsp;</a></span>srgenc_hable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, T&gt; pr::srgenc_hable </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB with Hable tonemapping. </p>
<p class="formulaDsp">
\[ \operatorname{srgbenc}_{\text{Hable}}(v) = \operatorname{srgbenc}\left( \frac{5.50710 v^2 + 0.91785 v + 0.036714} {3.99336 v^2 + 6.65560 v + 0.399336} - \frac{0.61190}{6.65560}\right) \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">This article</a> by John Hable. </dd></dl>

</div>
</div>
<a id="gafdbd102f61722f5dd4d51dec96344516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbd102f61722f5dd4d51dec96344516">&#9670;&nbsp;</a></span>srgbenc_hable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::srgbenc_hable </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB with Hable tonemapping. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbenc}_{\text{Hable}}(r) \\ \operatorname{srgbenc}_{\text{Hable}}(g) \\ \operatorname{srgbenc}_{\text{Hable}}(b) \end{bmatrix} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">This article</a> by John Hable. </dd></dl>

</div>
</div>
<a id="ga804a63d68dd03085d2606477b6783e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804a63d68dd03085d2606477b6783e3f">&#9670;&nbsp;</a></span>srgbenc_hable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;T, 4&gt; &gt; pr::srgbenc_hable </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB with Hable tonemapping. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \\ \alpha&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbenc}_{\text{Hable}}(r) \\ \operatorname{srgbenc}_{\text{Hable}}(g) \\ \operatorname{srgbenc}_{\text{Hable}}(b) \\ \alpha \end{bmatrix} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">This article</a> by John Hable. </dd></dl>

</div>
</div>
<a id="ga3ead7c347597d328232539849fe1cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ead7c347597d328232539849fe1cc60">&#9670;&nbsp;</a></span>srgbenc_hejl_burgess() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, T&gt; pr::srgbenc_hejl_burgess </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB with Hejl/Burgess-Dawson tonemapping. </p>
<p class="formulaDsp">
\[ \operatorname{srgbenc}_{\text{Hejl/Burgess}}(v) = \frac{6.2 \max(v - 0.004, 0)^2 + 0.5 \max(v - 0.004, 0)} {6.2 \max(v - 0.004, 0)^2 + 1.7 \max(v - 0.004, 0) + 0.06} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">This article</a> by John Hable. </dd></dl>

</div>
</div>
<a id="ga9a23fe2ecde5ac27c733d4b14c1ce5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a23fe2ecde5ac27c733d4b14c1ce5f8">&#9670;&nbsp;</a></span>srgbenc_hejl_burgess() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::srgbenc_hejl_burgess </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB with Hejl/Burgess-Dawson tonemapping. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbenc}_{\text{Hejl/Burgess}}(r) \\ \operatorname{srgbenc}_{\text{Hejl/Burgess}}(g) \\ \operatorname{srgbenc}_{\text{Hejl/Burgess}}(b) \end{bmatrix} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">This article</a> by John Hable. </dd></dl>

</div>
</div>
<a id="ga3e74ba174cda38e397ed51d80b4f43d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e74ba174cda38e397ed51d80b4f43d4">&#9670;&nbsp;</a></span>srgbenc_hejl_burgess() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;T, 4&gt; &gt; pr::srgbenc_hejl_burgess </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode linear RGB as sRGB with Hejl/Burgess-Dawson tonemapping. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} r&#39; \\ g&#39; \\ b&#39; \\ \alpha&#39; \end{bmatrix} \gets \begin{bmatrix} \operatorname{srgbenc}_{\text{Hejl/Burgess}}(r) \\ \operatorname{srgbenc}_{\text{Hejl/Burgess}}(g) \\ \operatorname{srgbenc}_{\text{Hejl/Burgess}}(b) \\ \alpha \end{bmatrix} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">This article</a> by John Hable. </dd></dl>

</div>
</div>
<a id="ga0594859191efad40acebcde02935a74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0594859191efad40acebcde02935a74d">&#9670;&nbsp;</a></span>wymanx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::value, T&gt; pr::wymanx </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit of CIE 1931 X by Wyman et. al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Wavelength in micrometers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://jcgt.org/published/0002/02/01/">This publication</a> by Wyman, Sloan, and Shirley. </dd></dl>

</div>
</div>
<a id="ga18f9c3e985140538310bbff58f34c964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f9c3e985140538310bbff58f34c964">&#9670;&nbsp;</a></span>wymany()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::value, T&gt; pr::wymany </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit of CIE 1931 Y by Wyman et. al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Wavelength in micrometers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://jcgt.org/published/0002/02/01/">This publication</a> by Wyman, Sloan, and Shirley. </dd></dl>

</div>
</div>
<a id="ga21180a1a0b538a534b30f90a09cd2d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21180a1a0b538a534b30f90a09cd2d81">&#9670;&nbsp;</a></span>wymanz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::value, T&gt; pr::wymanz </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit of CIE 1931 Z by Wyman et. al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Wavelength in micrometers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://jcgt.org/published/0002/02/01/">This publication</a> by Wyman, Sloan, and Shirley. </dd></dl>

</div>
</div>
<a id="ga935d39309a1cf80227c06e94f7cab8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935d39309a1cf80227c06e94f7cab8ac">&#9670;&nbsp;</a></span>planck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, T&gt; pr::planck </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Planck's law. </p>
<p>Planck's law of blackbody radiation is </p><p class="formulaDsp">
\[ b(T,\lambda) = \frac{1}{\lambda^5} \frac{2hc^2}{e^{\frac{hc}{kT\lambda}}-1} \]
</p>
<p> where, by typical conventions, \( T \) is temperature in degrees kelvin and \( \lambda \) is wavelength in meters. The implementation here takes \( \lambda \) in <em>micrometers</em> instead of meters, but in the interest of avoiding astronomic values, the output units are \( \mathrm{MW}/\mathrm{sr}/\mathrm{m}^{2}/\mu\mathrm{m} \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Blackbody temperature in degrees kelvin.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Wavelength in micrometers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Wikipedia's article for <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck's Law</a>. </dd></dl>

</div>
</div>
<a id="ga16fb0557f89adecff79f82d6b24d368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16fb0557f89adecff79f82d6b24d368f">&#9670;&nbsp;</a></span>xyztorgb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::xyztorgb </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XYZ triple to RGB triple. </p>
<p>This uses standard CIE parameters:</p><ul>
<li>\( C_r = (0.7350, 0.2650) \),</li>
<li>\( C_g = (0.2740, 0.7170) \),</li>
<li>\( C_b = (0.1670, 0.0090) \), and</li>
<li>\( W = (1, 1, 1) \).</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">Bruce Lindbloom's page</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga73b50f493f77b11fecb8860e1d73f351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b50f493f77b11fecb8860e1d73f351">&#9670;&nbsp;</a></span>rgbtoxyz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::rgbtoxyz </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RGB triple to XYZ triple. </p>
<p>This uses standard CIE parameters:</p><ul>
<li>\( C_r = (0.7350, 0.2650) \),</li>
<li>\( C_g = (0.2740, 0.7170) \),</li>
<li>\( C_b = (0.1670, 0.0090) \), and</li>
<li>\( W = (1, 1, 1) \).</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">Bruce Lindbloom's page</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga78bb6816b92a84fb48fcfcc00b60a598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78bb6816b92a84fb48fcfcc00b60a598">&#9670;&nbsp;</a></span>rgbtoxyz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3, 3&gt; &gt; pr::rgbtoxyz </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RGB to XYZ conversion matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">Bruce Lindbloom's page</a>. </dd></dl>

</div>
</div>
<a id="gae49beaf7bd690269c1b2f360e679e479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49beaf7bd690269c1b2f360e679e479">&#9670;&nbsp;</a></span>xyztolab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::xyztolab </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XYZ triple to Lab triple. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} L \\ a \\ b \end{bmatrix} \gets \begin{bmatrix} 116 f(Y) - 16 \\ 500 (f(X) - f(Y)) \\ 200 (f(Y) - f(Z)) \end{bmatrix} \]
</p>
<p> where </p><p class="formulaDsp">
\[ f(t) = \begin{cases} t^{1/3} &amp; t &gt; 216 / 24389 \\ ((24389 / 27) t + 16) / 116 &amp; t \le 216 / 24389 \end{cases} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://brucelindbloom.com/index.html?Eqn_XYZ_to_Lab.html">Bruce Lindbloom's page</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga09ea7e7ab04b535c4e8c361fdf37bfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09ea7e7ab04b535c4e8c361fdf37bfed">&#9670;&nbsp;</a></span>labtoxyz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, 3&gt; &gt; pr::labtoxyz </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lab triple to XYZ triple. </p>
<p class="formulaDsp">
\[ \begin{bmatrix} X \\ Y \\ Z \end{bmatrix} \gets \begin{bmatrix} f^{-1}(f_X) \\ f^{-1}(f_Y) \\ f^{-1}(f_Z) \end{bmatrix} \]
</p>
<p> where </p><p class="formulaDsp">
\[ \begin{aligned} f_Y &amp;= (L + 16) / 116 \\ f_X &amp;= f_Y + a / 500 \\ f_Z &amp;= f_Y - b / 200 \end{aligned} \]
</p>
<p> and where </p><p class="formulaDsp">
\[ f^{-1}(t) = \begin{cases} t^3 &amp; t^3 &gt; 216 / 24389 \\ (116 t - 16) (27 / 24389) &amp; t^3 \le 216 / 24389 \end{cases} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://brucelindbloom.com/index.html?Eqn_Lab_to_XYZ.html">Bruce Lindbloom's page</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac8c7ffc6449a317efafbf42fe99a6d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8c7ffc6449a317efafbf42fe99a6d72">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* pr::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">composite_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composite mode to string. </p>

</div>
</div>
<a id="ga3c3b565c08cd5b2f5f8a2fe20a967f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c3b565c08cd5b2f5f8a2fe20a967f4f">&#9670;&nbsp;</a></span>premultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, N&gt; &gt; pr::premultiply </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Premultiply. </p>
<p class="formulaDsp">
\[ \operatorname{premultiply}( \mathbf{v} = [\mathbf{c} \;\; \alpha]^\top) = [\alpha \mathbf{c} \;\; \alpha]^\top \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga43316a39287860d63001822fc941bf80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43316a39287860d63001822fc941bf80">&#9670;&nbsp;</a></span>unpremultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, N&gt; &gt; pr::unpremultiply </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpremultiply. </p>
<p class="formulaDsp">
\[ \operatorname{unpremultiply}( \mathbf{v} = [\mathbf{c} \;\; \alpha]^\top) = \begin{cases} [\mathbf{c} / \alpha \;\; \alpha]^\top &amp; \alpha &gt; 0 \\ [\mathbf{c} \;\; \alpha]^\top &amp; \alpha = 0 \end{cases} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga470180292b667ad49c8b4878c96392cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470180292b667ad49c8b4878c96392cb">&#9670;&nbsp;</a></span>composite_premul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, N&gt; &gt; pr::composite_premul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">composite_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vdst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composite via Porter-Duff equation (premultiplied). </p>
<p class="formulaDsp">
\[ \mathbf{v} \gets f_{\text{src}} \mathbf{v}_{\text{src}} + f_{\text{dst}} \mathbf{v}_{\text{dst}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga432e8791de819ee15c5ad96e8ee2de87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432e8791de819ee15c5ad96e8ee2de87">&#9670;&nbsp;</a></span>composite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value, multi&lt;T, N&gt; &gt; pr::composite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__color.html#ga09c109ef2e17c54f12210b6f7c805905">composite_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vdst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composite via Porter-Duff equation. </p>
<p class="formulaDsp">
\[ \mathbf{v} \gets \operatorname{unpremultiply}( f_{\text{src}} \operatorname{premultiply}(\mathbf{v}_{\text{src}}) + f_{\text{dst}} \operatorname{premultiply}(\mathbf{v}_{\text{dst}})) \]
</p>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is an unsigned integral type,<ul>
<li>uses <code>fstretch()</code> to convert to <code>double</code> before recursing, then</li>
<li>uses <code>fstretch()</code> to convert to <code>T</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga44549f77aa01311130c1c8686724b4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44549f77aa01311130c1c8686724b4eb">&#9670;&nbsp;</a></span>pack_uint8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, std::uint8_t&gt; pr::pack_uint8 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::uint8_t&gt;()</code>. </p>

</div>
</div>
<a id="ga8884b5244d17d7423a48636ed70eae7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8884b5244d17d7423a48636ed70eae7a">&#9670;&nbsp;</a></span>pack_uint16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, std::uint16_t&gt; pr::pack_uint16 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::uint16_t&gt;()</code>. </p>

</div>
</div>
<a id="ga0249a0aa7bc20e0165a9930627c80b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0249a0aa7bc20e0165a9930627c80b42">&#9670;&nbsp;</a></span>pack_uint32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, std::uint32_t&gt; pr::pack_uint32 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::uint32_t&gt;()</code>. </p>

</div>
</div>
<a id="gae43b7a37d1e26e90e59fe4597d84178e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae43b7a37d1e26e90e59fe4597d84178e">&#9670;&nbsp;</a></span>pack_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, std::int8_t&gt; pr::pack_int8 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::int8_t&gt;()</code>. </p>

</div>
</div>
<a id="gae224fa7230a06c52e7890ebda5168611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae224fa7230a06c52e7890ebda5168611">&#9670;&nbsp;</a></span>pack_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, std::int16_t&gt; pr::pack_int16 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::int16_t&gt;()</code>. </p>

</div>
</div>
<a id="ga68fe358339010ef6a9e9423ce782240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68fe358339010ef6a9e9423ce782240b">&#9670;&nbsp;</a></span>pack_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, std::int32_t&gt; pr::pack_int32 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::int32_t&gt;()</code>. </p>

</div>
</div>
<a id="gabd0c299f44bd39299924e3612f3bb935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd0c299f44bd39299924e3612f3bb935">&#9670;&nbsp;</a></span>pack_uint8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;std::uint8_t, N&gt; &gt; pr::pack_uint8 </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::uint8_t&gt;()</code>. </p>

</div>
</div>
<a id="ga9d8d4ebed0f796d470e177d8aa768f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8d4ebed0f796d470e177d8aa768f66">&#9670;&nbsp;</a></span>pack_uint16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;std::uint16_t, N&gt; &gt; pr::pack_uint16 </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::uint16_t&gt;()</code>. </p>

</div>
</div>
<a id="ga2944eb274ea9d43f4bbdaa4a61fab3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2944eb274ea9d43f4bbdaa4a61fab3fd">&#9670;&nbsp;</a></span>pack_uint32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;std::uint32_t, N&gt; &gt; pr::pack_uint32 </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::uint32_t&gt;()</code>. </p>

</div>
</div>
<a id="gab1b191e69c45b944a362c87b3fc080b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b191e69c45b944a362c87b3fc080b6">&#9670;&nbsp;</a></span>pack_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;std::int8_t, N&gt; &gt; pr::pack_int8 </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::int8_t&gt;()</code>. </p>

</div>
</div>
<a id="gaa1382f7905f44b3c97d88ba00112fdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1382f7905f44b3c97d88ba00112fdaf">&#9670;&nbsp;</a></span>pack_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;std::int16_t, N&gt; &gt; pr::pack_int16 </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::int16_t&gt;()</code>. </p>

</div>
</div>
<a id="gaaac3d0ee928590110bf9fe3e8518843a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac3d0ee928590110bf9fe3e8518843a">&#9670;&nbsp;</a></span>pack_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point&lt;T&gt;::value, multi&lt;std::int32_t, N&gt; &gt; pr::pack_int32 </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;std::int32_t&gt;()</code>. </p>

</div>
</div>
<a id="ga81f5d0c84d97a26cdf11ee30a0d6c5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81f5d0c84d97a26cdf11ee30a0d6c5b1">&#9670;&nbsp;</a></span>unpack_float() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, float&gt; pr::unpack_float </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;float&gt;()</code>. </p>

</div>
</div>
<a id="ga425531deba1372b278c28860493d72ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425531deba1372b278c28860493d72ae">&#9670;&nbsp;</a></span>unpack_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, double&gt; pr::unpack_double </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;double&gt;()</code>. </p>

</div>
</div>
<a id="ga72ff38529455512e68bb681ca9552c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ff38529455512e68bb681ca9552c66">&#9670;&nbsp;</a></span>unpack_float() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, multi&lt;float, N&gt; &gt; pr::unpack_float </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;float&gt;()</code>. </p>

</div>
</div>
<a id="gadff505b5b2261a82ea8bd2d5311d67a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff505b5b2261a82ea8bd2d5311d67a6">&#9670;&nbsp;</a></span>unpack_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, multi&lt;double, N&gt; &gt; pr::unpack_double </td>
          <td>(</td>
          <td class="paramtype">const multi&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>fstretch&lt;double&gt;()</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
