<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>preform: pre::multi&lt; T, M, N... &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<!--Broken...-->
<!--<script type="text/javascript" src="dynsections.js"></script>-->
<!--Load MathJax manually...-->
<!--cdn.mathjax.org shutting down April 30th, 2019
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
MathJax.Hub.Config({
  displayAlign: "left",
  displayIndent: "2em",
  TeX: {
    Macros: {
        real: ["\\operatorname{Re}"],
        imag: ["\\operatorname{Im}"],
        dual: ["\\operatorname{Du}"],
        symm: ["\\operatorname{Symm}"],
        skew: ["\\operatorname{Skew}"],
        erf: ["\\operatorname{erf}"],
        erfc: ["\\operatorname{erfc}"],
        normalize: ["\\operatorname{normalize}"],
        argmin: ["\\operatorname{argmin}"],
        argmax: ["\\operatorname{argmax}"]
    }
  }
});
</script>
<script type="text/javascript" src="DoxygenFix.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">preform
   </div>
   <div id="projectbrief">C++ header-only utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepre.html">pre</a></li><li class="navelem"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html">multi&lt; T, M, N... &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pre::multi&lt; T, M, N... &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__multi.html">Multi-dimensional array</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Multi-dimensional array.  
 <a href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pre::multi&lt; T, M, N... &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4__inherit__graph.svg" width="227" height="232"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind entry type.  <a href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Container typedefs</div></td></tr>
<tr class="memitem:a501812ac2dd4831ad3137673019e0bb6"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a></td></tr>
<tr class="memdesc:a501812ac2dd4831ad3137673019e0bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a501812ac2dd4831ad3137673019e0bb6">More...</a><br /></td></tr>
<tr class="separator:a501812ac2dd4831ad3137673019e0bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2638f6b5363f4d50ed01a13c58b4a335"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a2638f6b5363f4d50ed01a13c58b4a335">difference_type</a></td></tr>
<tr class="memdesc:a2638f6b5363f4d50ed01a13c58b4a335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type.  <a href="#a2638f6b5363f4d50ed01a13c58b4a335">More...</a><br /></td></tr>
<tr class="separator:a2638f6b5363f4d50ed01a13c58b4a335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f1064d7fb7ffcb50e0ece561c8b465"><td class="memItemLeft" align="right" valign="top">typedef multi_value_type&lt; T, N... &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a></td></tr>
<tr class="memdesc:af5f1064d7fb7ffcb50e0ece561c8b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <a href="#af5f1064d7fb7ffcb50e0ece561c8b465">More...</a><br /></td></tr>
<tr class="separator:af5f1064d7fb7ffcb50e0ece561c8b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63f4604a563d8afdfeac2726ed800d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab63f4604a563d8afdfeac2726ed800d5">reference</a></td></tr>
<tr class="memdesc:ab63f4604a563d8afdfeac2726ed800d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference.  <a href="#ab63f4604a563d8afdfeac2726ed800d5">More...</a><br /></td></tr>
<tr class="separator:ab63f4604a563d8afdfeac2726ed800d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f7146642a24f814a45ce1b23696945"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab0f7146642a24f814a45ce1b23696945">pointer</a></td></tr>
<tr class="memdesc:ab0f7146642a24f814a45ce1b23696945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer.  <a href="#ab0f7146642a24f814a45ce1b23696945">More...</a><br /></td></tr>
<tr class="separator:ab0f7146642a24f814a45ce1b23696945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803086da400697511ed10a936fce4e0c"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a803086da400697511ed10a936fce4e0c">const_reference</a></td></tr>
<tr class="memdesc:a803086da400697511ed10a936fce4e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference.  <a href="#a803086da400697511ed10a936fce4e0c">More...</a><br /></td></tr>
<tr class="separator:a803086da400697511ed10a936fce4e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee9eb1ab1d1bf7e588cfd948aa09c5"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a75ee9eb1ab1d1bf7e588cfd948aa09c5">const_pointer</a></td></tr>
<tr class="memdesc:a75ee9eb1ab1d1bf7e588cfd948aa09c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer.  <a href="#a75ee9eb1ab1d1bf7e588cfd948aa09c5">More...</a><br /></td></tr>
<tr class="separator:a75ee9eb1ab1d1bf7e588cfd948aa09c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465816ad75a7c41ad5c0d4ee91cce7a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab0f7146642a24f814a45ce1b23696945">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a></td></tr>
<tr class="memdesc:a465816ad75a7c41ad5c0d4ee91cce7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator.  <a href="#a465816ad75a7c41ad5c0d4ee91cce7a8">More...</a><br /></td></tr>
<tr class="separator:a465816ad75a7c41ad5c0d4ee91cce7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8876addc1c44d9e0fa693c9319cb4a9a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a75ee9eb1ab1d1bf7e588cfd948aa09c5">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a></td></tr>
<tr class="memdesc:a8876addc1c44d9e0fa693c9319cb4a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator.  <a href="#a8876addc1c44d9e0fa693c9319cb4a9a">More...</a><br /></td></tr>
<tr class="separator:a8876addc1c44d9e0fa693c9319cb4a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7ba5bce5775012b2424ff3b3862ba6"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aca7ba5bce5775012b2424ff3b3862ba6">reverse_iterator</a></td></tr>
<tr class="memdesc:aca7ba5bce5775012b2424ff3b3862ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator.  <a href="#aca7ba5bce5775012b2424ff3b3862ba6">More...</a><br /></td></tr>
<tr class="separator:aca7ba5bce5775012b2424ff3b3862ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dc1428e3243e5b5bc315b266eacbdb"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aa0dc1428e3243e5b5bc315b266eacbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator.  <a href="#aa0dc1428e3243e5b5bc315b266eacbdb">More...</a><br /></td></tr>
<tr class="separator:aa0dc1428e3243e5b5bc315b266eacbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e4c8dd839df7db0d23e8e05665d0a"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a520e4c8dd839df7db0d23e8e05665d0a">entry_type</a></td></tr>
<tr class="memdesc:a520e4c8dd839df7db0d23e8e05665d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bottom-level entry type.  <a href="#a520e4c8dd839df7db0d23e8e05665d0a">More...</a><br /></td></tr>
<tr class="separator:a520e4c8dd839df7db0d23e8e05665d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53309a7cc0b27c5596d5653c93001c3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; T,(M *... *N)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ad53309a7cc0b27c5596d5653c93001c3">flatten_type</a></td></tr>
<tr class="memdesc:ad53309a7cc0b27c5596d5653c93001c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten type.  <a href="#ad53309a7cc0b27c5596d5653c93001c3">More...</a><br /></td></tr>
<tr class="separator:ad53309a7cc0b27c5596d5653c93001c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2ce4993e0302f35657f8032044954"><td class="memItemLeft" align="right" valign="top">typedef multi_initializer_list&lt; T, M, N... &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ac7a2ce4993e0302f35657f8032044954">initializer_list</a></td></tr>
<tr class="memdesc:ac7a2ce4993e0302f35657f8032044954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list.  <a href="#ac7a2ce4993e0302f35657f8032044954">More...</a><br /></td></tr>
<tr class="separator:ac7a2ce4993e0302f35657f8032044954"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abfe8f353749b89b121703e467d7548e3"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> ()=default</td></tr>
<tr class="memdesc:abfe8f353749b89b121703e467d7548e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#abfe8f353749b89b121703e467d7548e3">More...</a><br /></td></tr>
<tr class="separator:abfe8f353749b89b121703e467d7548e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1fb064f0742bd92c8f709cfbd918ac"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a0e1fb064f0742bd92c8f709cfbd918ac">multi</a> (<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ac7a2ce4993e0302f35657f8032044954">initializer_list</a> list)</td></tr>
<tr class="memdesc:a0e1fb064f0742bd92c8f709cfbd918ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a0e1fb064f0742bd92c8f709cfbd918ac">More...</a><br /></td></tr>
<tr class="separator:a0e1fb064f0742bd92c8f709cfbd918ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc6e659cc9d9e725a76a049017cfb05"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a9fc6e659cc9d9e725a76a049017cfb05">multi</a> (const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a520e4c8dd839df7db0d23e8e05665d0a">entry_type</a> &amp;ent)</td></tr>
<tr class="memdesc:a9fc6e659cc9d9e725a76a049017cfb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9fc6e659cc9d9e725a76a049017cfb05">More...</a><br /></td></tr>
<tr class="separator:a9fc6e659cc9d9e725a76a049017cfb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b10d9f06646250b7726681fc59831fd"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a4b10d9f06646250b7726681fc59831fd">multi</a> (const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a520e4c8dd839df7db0d23e8e05665d0a">entry_type</a> *ptr))</td></tr>
<tr class="memdesc:a4b10d9f06646250b7726681fc59831fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a4b10d9f06646250b7726681fc59831fd">More...</a><br /></td></tr>
<tr class="separator:a4b10d9f06646250b7726681fc59831fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Increment operators</div></td></tr>
<tr class="memitem:a32ad43bb6399b31acba33c9c6ced553d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a32ad43bb6399b31acba33c9c6ced553d">operator++</a> ()</td></tr>
<tr class="memdesc:a32ad43bb6399b31acba33c9c6ced553d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entrywise pre-increment.  <a href="#a32ad43bb6399b31acba33c9c6ced553d">More...</a><br /></td></tr>
<tr class="separator:a32ad43bb6399b31acba33c9c6ced553d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad112a098e218e7433f9fecec0d8bf232"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ad112a098e218e7433f9fecec0d8bf232">operator--</a> ()</td></tr>
<tr class="memdesc:ad112a098e218e7433f9fecec0d8bf232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entrywise pre-decrement.  <a href="#ad112a098e218e7433f9fecec0d8bf232">More...</a><br /></td></tr>
<tr class="separator:ad112a098e218e7433f9fecec0d8bf232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aab964fe6914255eab4e8035b4fccd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a08aab964fe6914255eab4e8035b4fccd">operator++</a> (int)</td></tr>
<tr class="memdesc:a08aab964fe6914255eab4e8035b4fccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entrywise post-increment.  <a href="#a08aab964fe6914255eab4e8035b4fccd">More...</a><br /></td></tr>
<tr class="separator:a08aab964fe6914255eab4e8035b4fccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981590fde9a01cc4c74c289324d9ff77"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a981590fde9a01cc4c74c289324d9ff77">operator--</a> (int)</td></tr>
<tr class="memdesc:a981590fde9a01cc4c74c289324d9ff77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entrywise post-decrement.  <a href="#a981590fde9a01cc4c74c289324d9ff77">More...</a><br /></td></tr>
<tr class="separator:a981590fde9a01cc4c74c289324d9ff77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Folds</div></td></tr>
<tr class="memitem:a188a23b3ab26cbb01079bf53af8e52ea"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a188a23b3ab26cbb01079bf53af8e52ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a188a23b3ab26cbb01079bf53af8e52ea">foldl</a> (F &amp;&amp;func) const</td></tr>
<tr class="memdesc:a188a23b3ab26cbb01079bf53af8e52ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-to-right fold.  <a href="#a188a23b3ab26cbb01079bf53af8e52ea">More...</a><br /></td></tr>
<tr class="separator:a188a23b3ab26cbb01079bf53af8e52ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb52191994d46cd5a0ab5244175823a7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aeb52191994d46cd5a0ab5244175823a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aeb52191994d46cd5a0ab5244175823a7">foldr</a> (F &amp;&amp;func) const</td></tr>
<tr class="memdesc:aeb52191994d46cd5a0ab5244175823a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-to-left fold.  <a href="#aeb52191994d46cd5a0ab5244175823a7">More...</a><br /></td></tr>
<tr class="separator:aeb52191994d46cd5a0ab5244175823a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79756f599551fac82e04a35860a6783"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ad79756f599551fac82e04a35860a6783"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ad79756f599551fac82e04a35860a6783">foldl_accum</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:ad79756f599551fac82e04a35860a6783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-to-right accumulating fold.  <a href="#ad79756f599551fac82e04a35860a6783">More...</a><br /></td></tr>
<tr class="separator:ad79756f599551fac82e04a35860a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d039d4ffbcb24cffbe0f27f3032385"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a58d039d4ffbcb24cffbe0f27f3032385"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a58d039d4ffbcb24cffbe0f27f3032385">foldr_accum</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:a58d039d4ffbcb24cffbe0f27f3032385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-to-left accumulating fold.  <a href="#a58d039d4ffbcb24cffbe0f27f3032385">More...</a><br /></td></tr>
<tr class="separator:a58d039d4ffbcb24cffbe0f27f3032385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4385edf932732c377925fc5eb23979f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:af4385edf932732c377925fc5eb23979f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af4385edf932732c377925fc5eb23979f">foldl_adjacent</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:af4385edf932732c377925fc5eb23979f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-to-right adjacent fold.  <a href="#af4385edf932732c377925fc5eb23979f">More...</a><br /></td></tr>
<tr class="separator:af4385edf932732c377925fc5eb23979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b183a81df8b98e5ef7a33ed89b84d4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a81b183a81df8b98e5ef7a33ed89b84d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a81b183a81df8b98e5ef7a33ed89b84d4">foldr_adjacent</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:a81b183a81df8b98e5ef7a33ed89b84d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-to-left adjacent fold.  <a href="#a81b183a81df8b98e5ef7a33ed89b84d4">More...</a><br /></td></tr>
<tr class="separator:a81b183a81df8b98e5ef7a33ed89b84d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fold utilities</div></td></tr>
<tr class="memitem:a9b13901c56aca76ebd33c911703f523b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a9b13901c56aca76ebd33c911703f523b">sum</a> () const</td></tr>
<tr class="memdesc:a9b13901c56aca76ebd33c911703f523b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum.  <a href="#a9b13901c56aca76ebd33c911703f523b">More...</a><br /></td></tr>
<tr class="separator:a9b13901c56aca76ebd33c911703f523b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50160c1334f60b2d2f6b53019d761933"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a50160c1334f60b2d2f6b53019d761933">prod</a> () const</td></tr>
<tr class="memdesc:a50160c1334f60b2d2f6b53019d761933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product.  <a href="#a50160c1334f60b2d2f6b53019d761933">More...</a><br /></td></tr>
<tr class="separator:a50160c1334f60b2d2f6b53019d761933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a5610275707dc2f86815c3d36236e5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a95a5610275707dc2f86815c3d36236e5">accum_sum</a> ()</td></tr>
<tr class="memdesc:a95a5610275707dc2f86815c3d36236e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulating sum.  <a href="#a95a5610275707dc2f86815c3d36236e5">More...</a><br /></td></tr>
<tr class="separator:a95a5610275707dc2f86815c3d36236e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d508d97634c224c7bcc9e879091538"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a85d508d97634c224c7bcc9e879091538">adjacent_difference</a> ()</td></tr>
<tr class="memdesc:a85d508d97634c224c7bcc9e879091538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacent difference.  <a href="#a85d508d97634c224c7bcc9e879091538">More...</a><br /></td></tr>
<tr class="separator:a85d508d97634c224c7bcc9e879091538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reshaping</div></td></tr>
<tr class="memitem:a49b6636d3db44a2646e4df3b99dbb5d9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a49b6636d3db44a2646e4df3b99dbb5d9">fill</a> (const T &amp;ent)</td></tr>
<tr class="memdesc:a49b6636d3db44a2646e4df3b99dbb5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill from entry.  <a href="#a49b6636d3db44a2646e4df3b99dbb5d9">More...</a><br /></td></tr>
<tr class="separator:a49b6636d3db44a2646e4df3b99dbb5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6270ae7f3242486ebc69662fb3c200ca"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a6270ae7f3242486ebc69662fb3c200ca">fill</a> (const T *ptr))</td></tr>
<tr class="memdesc:a6270ae7f3242486ebc69662fb3c200ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill from entry array.  <a href="#a6270ae7f3242486ebc69662fb3c200ca">More...</a><br /></td></tr>
<tr class="separator:a6270ae7f3242486ebc69662fb3c200ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52f9eabed46f22329193f1a0ddd333"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ad53309a7cc0b27c5596d5653c93001c3">flatten_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a2e52f9eabed46f22329193f1a0ddd333">flatten</a> () const</td></tr>
<tr class="memdesc:a2e52f9eabed46f22329193f1a0ddd333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten.  <a href="#a2e52f9eabed46f22329193f1a0ddd333">More...</a><br /></td></tr>
<tr class="separator:a2e52f9eabed46f22329193f1a0ddd333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbd51275fdb1b2bd6d2351c957e7524"><td class="memTemplParams" colspan="2">template&lt;std::size_t... K&gt; </td></tr>
<tr class="memitem:a3dbd51275fdb1b2bd6d2351c957e7524"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; T, K... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a3dbd51275fdb1b2bd6d2351c957e7524">reshape</a> () const</td></tr>
<tr class="memdesc:a3dbd51275fdb1b2bd6d2351c957e7524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape.  <a href="#a3dbd51275fdb1b2bd6d2351c957e7524">More...</a><br /></td></tr>
<tr class="separator:a3dbd51275fdb1b2bd6d2351c957e7524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8831dbe916ceba564d0dde71ba7e98e5"><td class="memTemplParams" colspan="2">template&lt;typename U , std::size_t... K&gt; </td></tr>
<tr class="memitem:a8831dbe916ceba564d0dde71ba7e98e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8831dbe916ceba564d0dde71ba7e98e5">operator multi&lt; U, K... &gt;</a> () const</td></tr>
<tr class="memdesc:a8831dbe916ceba564d0dde71ba7e98e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast operator.  <a href="#a8831dbe916ceba564d0dde71ba7e98e5">More...</a><br /></td></tr>
<tr class="separator:a8831dbe916ceba564d0dde71ba7e98e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08023aeb008fd4e005568b3eb6212701"><td class="memTemplParams" colspan="2">template&lt;bool B = (M == 1 &amp;&amp; (... &amp;&amp; (N == 1)))&gt; </td></tr>
<tr class="memitem:a08023aeb008fd4e005568b3eb6212701"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a08023aeb008fd4e005568b3eb6212701">operator std::enable_if_t&lt; B, const T &amp; &gt;</a> () const</td></tr>
<tr class="memdesc:a08023aeb008fd4e005568b3eb6212701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast operator.  <a href="#a08023aeb008fd4e005568b3eb6212701">More...</a><br /></td></tr>
<tr class="separator:a08023aeb008fd4e005568b3eb6212701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adee7bfe1ab6ec66686fab50a3bc608"><td class="memTemplParams" colspan="2">template&lt;typename P , std::size_t K&gt; </td></tr>
<tr class="memitem:a4adee7bfe1ab6ec66686fab50a3bc608"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; T, K, N... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a4adee7bfe1ab6ec66686fab50a3bc608">swizzle</a> (const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, K &gt; &amp;k) const</td></tr>
<tr class="memdesc:a4adee7bfe1ab6ec66686fab50a3bc608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swizzle.  <a href="#a4adee7bfe1ab6ec66686fab50a3bc608">More...</a><br /></td></tr>
<tr class="separator:a4adee7bfe1ab6ec66686fab50a3bc608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9719e812af35a389bc979701ef713d"><td class="memTemplParams" colspan="2">template&lt;typename P , typename... Q&gt; </td></tr>
<tr class="memitem:abf9719e812af35a389bc979701ef713d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; T, 1+sizeof...(Q), N... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abf9719e812af35a389bc979701ef713d">swizzle</a> (P p, Q &amp;&amp;... q) const</td></tr>
<tr class="memdesc:abf9719e812af35a389bc979701ef713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swizzle.  <a href="#abf9719e812af35a389bc979701ef713d">More...</a><br /></td></tr>
<tr class="separator:abf9719e812af35a389bc979701ef713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tests</div></td></tr>
<tr class="memitem:ab89281349394784cc0eac396217a26b6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab89281349394784cc0eac396217a26b6">any</a> () const</td></tr>
<tr class="memdesc:ab89281349394784cc0eac396217a26b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any entries true?  <a href="#ab89281349394784cc0eac396217a26b6">More...</a><br /></td></tr>
<tr class="separator:ab89281349394784cc0eac396217a26b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9607fd879b164cf2214c6046adea7ae4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a9607fd879b164cf2214c6046adea7ae4">all</a> () const</td></tr>
<tr class="memdesc:a9607fd879b164cf2214c6046adea7ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">All entries true?  <a href="#a9607fd879b164cf2214c6046adea7ae4">More...</a><br /></td></tr>
<tr class="separator:a9607fd879b164cf2214c6046adea7ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c217c34eff2295ff2d13d1de9d32bb6"><td class="memTemplParams" colspan="2">template&lt;bool B = (sizeof...(N) == 0)&gt; </td></tr>
<tr class="memitem:a9c217c34eff2295ff2d13d1de9d32bb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; B, <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a9c217c34eff2295ff2d13d1de9d32bb6">argmin</a> () const</td></tr>
<tr class="memdesc:a9c217c34eff2295ff2d13d1de9d32bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of minimum element.  <a href="#a9c217c34eff2295ff2d13d1de9d32bb6">More...</a><br /></td></tr>
<tr class="separator:a9c217c34eff2295ff2d13d1de9d32bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af084e4e4da7eb38ab33706ef7b5cc25b"><td class="memTemplParams" colspan="2">template&lt;bool B = (sizeof...(N) == 0)&gt; </td></tr>
<tr class="memitem:af084e4e4da7eb38ab33706ef7b5cc25b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; B, <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af084e4e4da7eb38ab33706ef7b5cc25b">argmax</a> () const</td></tr>
<tr class="memdesc:af084e4e4da7eb38ab33706ef7b5cc25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of maximum element.  <a href="#af084e4e4da7eb38ab33706ef7b5cc25b">More...</a><br /></td></tr>
<tr class="separator:af084e4e4da7eb38ab33706ef7b5cc25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a679bf363295a4dae5293c95091a4cbea"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a679bf363295a4dae5293c95091a4cbea">alignment</a> () noexcept</td></tr>
<tr class="memdesc:a679bf363295a4dae5293c95091a4cbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array alignment, to promote vectorization by compiler.  <a href="#a679bf363295a4dae5293c95091a4cbea">More...</a><br /></td></tr>
<tr class="separator:a679bf363295a4dae5293c95091a4cbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a51d622ef17619329fd1524c4cf6a6adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a51d622ef17619329fd1524c4cf6a6adf">v_</a> [M] = {}</td></tr>
<tr class="memdesc:a51d622ef17619329fd1524c4cf6a6adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array.  <a href="#a51d622ef17619329fd1524c4cf6a6adf">More...</a><br /></td></tr>
<tr class="separator:a51d622ef17619329fd1524c4cf6a6adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream operators</div></td></tr>
<tr class="memitem:a7ded58356a37341d5d0ed6bf7bc26462"><td class="memTemplParams" colspan="2">template&lt;typename C , typename Ctraits &gt; </td></tr>
<tr class="memitem:a7ded58356a37341d5d0ed6bf7bc26462"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; C, Ctraits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a7ded58356a37341d5d0ed6bf7bc26462">operator&gt;&gt;</a> (std::basic_istream&lt; C, Ctraits &gt; &amp;is, <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;arr)</td></tr>
<tr class="memdesc:a7ded58356a37341d5d0ed6bf7bc26462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse from <code>std::basic_istream</code>.  <a href="#a7ded58356a37341d5d0ed6bf7bc26462">More...</a><br /></td></tr>
<tr class="separator:a7ded58356a37341d5d0ed6bf7bc26462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f5d9da2895e3540099e2a7f229d04"><td class="memTemplParams" colspan="2">template&lt;typename C , typename Ctraits &gt; </td></tr>
<tr class="memitem:a9e1f5d9da2895e3540099e2a7f229d04"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; C, Ctraits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a9e1f5d9da2895e3540099e2a7f229d04">operator&lt;&lt;</a> (std::basic_ostream&lt; C, Ctraits &gt; &amp;os, const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> &amp;arr)</td></tr>
<tr class="memdesc:a9e1f5d9da2895e3540099e2a7f229d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write into <code>std::basic_ostream</code>.  <a href="#a9e1f5d9da2895e3540099e2a7f229d04">More...</a><br /></td></tr>
<tr class="separator:a9e1f5d9da2895e3540099e2a7f229d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Container interface</h2></td></tr>
<tr class="memitem:a2732b1c51e540d715443f95145197a6d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a2732b1c51e540d715443f95145197a6d">begin</a> () noexcept</td></tr>
<tr class="memdesc:a2732b1c51e540d715443f95145197a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#a2732b1c51e540d715443f95145197a6d">More...</a><br /></td></tr>
<tr class="separator:a2732b1c51e540d715443f95145197a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49393003a0bad823ae399b5c4391fc27"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a49393003a0bad823ae399b5c4391fc27">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a49393003a0bad823ae399b5c4391fc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator, const variant.  <a href="#a49393003a0bad823ae399b5c4391fc27">More...</a><br /></td></tr>
<tr class="separator:a49393003a0bad823ae399b5c4391fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58563e3b91d8b4e3edeb76b63f381705"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a58563e3b91d8b4e3edeb76b63f381705">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a58563e3b91d8b4e3edeb76b63f381705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator, force const variant.  <a href="#a58563e3b91d8b4e3edeb76b63f381705">More...</a><br /></td></tr>
<tr class="separator:a58563e3b91d8b4e3edeb76b63f381705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dcb7ae084f7f4660c5cdb75483beb1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa9dcb7ae084f7f4660c5cdb75483beb1">end</a> () noexcept</td></tr>
<tr class="memdesc:aa9dcb7ae084f7f4660c5cdb75483beb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#aa9dcb7ae084f7f4660c5cdb75483beb1">More...</a><br /></td></tr>
<tr class="separator:aa9dcb7ae084f7f4660c5cdb75483beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6396198f5a13a065b034194a6551d4d0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a6396198f5a13a065b034194a6551d4d0">end</a> () const noexcept</td></tr>
<tr class="memdesc:a6396198f5a13a065b034194a6551d4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator, const variant.  <a href="#a6396198f5a13a065b034194a6551d4d0">More...</a><br /></td></tr>
<tr class="separator:a6396198f5a13a065b034194a6551d4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e351d274d24a1bf58be19ebf9e02ff"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab7e351d274d24a1bf58be19ebf9e02ff">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ab7e351d274d24a1bf58be19ebf9e02ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator, force const variant.  <a href="#ab7e351d274d24a1bf58be19ebf9e02ff">More...</a><br /></td></tr>
<tr class="separator:ab7e351d274d24a1bf58be19ebf9e02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c0db9c5ff97f8765fe36501945a810"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aca7ba5bce5775012b2424ff3b3862ba6">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a45c0db9c5ff97f8765fe36501945a810">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a45c0db9c5ff97f8765fe36501945a810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse begin iterator.  <a href="#a45c0db9c5ff97f8765fe36501945a810">More...</a><br /></td></tr>
<tr class="separator:a45c0db9c5ff97f8765fe36501945a810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37044d19f01d2868a97d7061b44bf49a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a37044d19f01d2868a97d7061b44bf49a">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a37044d19f01d2868a97d7061b44bf49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse begin iterator, const variant.  <a href="#a37044d19f01d2868a97d7061b44bf49a">More...</a><br /></td></tr>
<tr class="separator:a37044d19f01d2868a97d7061b44bf49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac3b2dc74b8cb16062d2cdef2d3b6e7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aaac3b2dc74b8cb16062d2cdef2d3b6e7">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aaac3b2dc74b8cb16062d2cdef2d3b6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse begin iterator, force const variant.  <a href="#aaac3b2dc74b8cb16062d2cdef2d3b6e7">More...</a><br /></td></tr>
<tr class="separator:aaac3b2dc74b8cb16062d2cdef2d3b6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa492e0545621ee7338fa7f0829b7ae"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aca7ba5bce5775012b2424ff3b3862ba6">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#acaa492e0545621ee7338fa7f0829b7ae">rend</a> () noexcept</td></tr>
<tr class="memdesc:acaa492e0545621ee7338fa7f0829b7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse end iterator.  <a href="#acaa492e0545621ee7338fa7f0829b7ae">More...</a><br /></td></tr>
<tr class="separator:acaa492e0545621ee7338fa7f0829b7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26bcf3273b5d69340769687eec35223"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ae26bcf3273b5d69340769687eec35223">rend</a> () const noexcept</td></tr>
<tr class="memdesc:ae26bcf3273b5d69340769687eec35223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse end iterator, const variant.  <a href="#ae26bcf3273b5d69340769687eec35223">More...</a><br /></td></tr>
<tr class="separator:ae26bcf3273b5d69340769687eec35223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3e462d5c79626fc6bbace95ab74c3f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a7a3e462d5c79626fc6bbace95ab74c3f">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a7a3e462d5c79626fc6bbace95ab74c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse end iterator, force const variant.  <a href="#a7a3e462d5c79626fc6bbace95ab74c3f">More...</a><br /></td></tr>
<tr class="separator:a7a3e462d5c79626fc6bbace95ab74c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e135396ac5ae6006b9d09315891dea4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab63f4604a563d8afdfeac2726ed800d5">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a3e135396ac5ae6006b9d09315891dea4">front</a> () noexcept</td></tr>
<tr class="memdesc:a3e135396ac5ae6006b9d09315891dea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Front element.  <a href="#a3e135396ac5ae6006b9d09315891dea4">More...</a><br /></td></tr>
<tr class="separator:a3e135396ac5ae6006b9d09315891dea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40232e8d00bbe928a2ec6d499dac1229"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a803086da400697511ed10a936fce4e0c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a40232e8d00bbe928a2ec6d499dac1229">front</a> () const noexcept</td></tr>
<tr class="memdesc:a40232e8d00bbe928a2ec6d499dac1229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Front element, const variant.  <a href="#a40232e8d00bbe928a2ec6d499dac1229">More...</a><br /></td></tr>
<tr class="separator:a40232e8d00bbe928a2ec6d499dac1229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bf1ac5a0124f406782e3835b7cd1a8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab63f4604a563d8afdfeac2726ed800d5">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a23bf1ac5a0124f406782e3835b7cd1a8">back</a> () noexcept</td></tr>
<tr class="memdesc:a23bf1ac5a0124f406782e3835b7cd1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back element.  <a href="#a23bf1ac5a0124f406782e3835b7cd1a8">More...</a><br /></td></tr>
<tr class="separator:a23bf1ac5a0124f406782e3835b7cd1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51281c5d66bd0cae5c1ad0438e632925"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a803086da400697511ed10a936fce4e0c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a51281c5d66bd0cae5c1ad0438e632925">back</a> () const noexcept</td></tr>
<tr class="memdesc:a51281c5d66bd0cae5c1ad0438e632925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back element, const variant.  <a href="#a51281c5d66bd0cae5c1ad0438e632925">More...</a><br /></td></tr>
<tr class="separator:a51281c5d66bd0cae5c1ad0438e632925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba66d65c9fd47a3d40efcfb84475c61"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8ba66d65c9fd47a3d40efcfb84475c61">size</a> () noexcept</td></tr>
<tr class="memdesc:a8ba66d65c9fd47a3d40efcfb84475c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size.  <a href="#a8ba66d65c9fd47a3d40efcfb84475c61">More...</a><br /></td></tr>
<tr class="separator:a8ba66d65c9fd47a3d40efcfb84475c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159153438bb097bf694b32f8f5fe8518"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a159153438bb097bf694b32f8f5fe8518">total_size</a> () noexcept</td></tr>
<tr class="memdesc:a159153438bb097bf694b32f8f5fe8518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size.  <a href="#a159153438bb097bf694b32f8f5fe8518">More...</a><br /></td></tr>
<tr class="separator:a159153438bb097bf694b32f8f5fe8518"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Access operators</h2></td></tr>
<tr class="memitem:a75b81ffb41f5b63eb9b06b9fcc654601"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a75b81ffb41f5b63eb9b06b9fcc654601"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a75b81ffb41f5b63eb9b06b9fcc654601">operator[]</a> (P p) noexcept</td></tr>
<tr class="memdesc:a75b81ffb41f5b63eb9b06b9fcc654601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index accessor.  <a href="#a75b81ffb41f5b63eb9b06b9fcc654601">More...</a><br /></td></tr>
<tr class="separator:a75b81ffb41f5b63eb9b06b9fcc654601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efc360706604ea98b6ab54451fe09f4"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a7efc360706604ea98b6ab54451fe09f4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a7efc360706604ea98b6ab54451fe09f4">operator[]</a> (P p) const noexcept</td></tr>
<tr class="memdesc:a7efc360706604ea98b6ab54451fe09f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index accessor, const variant.  <a href="#a7efc360706604ea98b6ab54451fe09f4">More...</a><br /></td></tr>
<tr class="separator:a7efc360706604ea98b6ab54451fe09f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60759291767b41b71ea7c35e05a3625a"><td class="memTemplParams" colspan="2">template&lt;typename P , typename... Q&gt; </td></tr>
<tr class="memitem:a60759291767b41b71ea7c35e05a3625a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a60759291767b41b71ea7c35e05a3625a">operator()</a> (P p, Q &amp;&amp;... q) noexcept</td></tr>
<tr class="memdesc:a60759291767b41b71ea7c35e05a3625a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple-index accessor.  <a href="#a60759291767b41b71ea7c35e05a3625a">More...</a><br /></td></tr>
<tr class="separator:a60759291767b41b71ea7c35e05a3625a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad82203e7f52a3c1cbcd11eaf505db86"><td class="memTemplParams" colspan="2">template&lt;typename P , typename... Q&gt; </td></tr>
<tr class="memitem:aad82203e7f52a3c1cbcd11eaf505db86"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aad82203e7f52a3c1cbcd11eaf505db86">operator()</a> (P p, Q &amp;&amp;... q) const noexcept</td></tr>
<tr class="memdesc:aad82203e7f52a3c1cbcd11eaf505db86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple-index accessor, const variant.  <a href="#aad82203e7f52a3c1cbcd11eaf505db86">More...</a><br /></td></tr>
<tr class="separator:aad82203e7f52a3c1cbcd11eaf505db86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d639e52ceed72b7b4d4e458c2222cf8"><td class="memTemplParams" colspan="2">template&lt;typename P , std::size_t K&gt; </td></tr>
<tr class="memitem:a1d639e52ceed72b7b4d4e458c2222cf8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a1d639e52ceed72b7b4d4e458c2222cf8">operator[]</a> (const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, K &gt; &amp;p) noexcept</td></tr>
<tr class="memdesc:a1d639e52ceed72b7b4d4e458c2222cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-index accessor.  <a href="#a1d639e52ceed72b7b4d4e458c2222cf8">More...</a><br /></td></tr>
<tr class="separator:a1d639e52ceed72b7b4d4e458c2222cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e95b30ce1940d39fc16d18b1bb5bab"><td class="memTemplParams" colspan="2">template&lt;typename P , std::size_t K&gt; </td></tr>
<tr class="memitem:a53e95b30ce1940d39fc16d18b1bb5bab"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a53e95b30ce1940d39fc16d18b1bb5bab">operator[]</a> (const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, K &gt; &amp;p) const noexcept</td></tr>
<tr class="memdesc:a53e95b30ce1940d39fc16d18b1bb5bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-index accessor, const variant.  <a href="#a53e95b30ce1940d39fc16d18b1bb5bab">More...</a><br /></td></tr>
<tr class="separator:a53e95b30ce1940d39fc16d18b1bb5bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c7ec737f59270c01f0d3c1376388f4"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a83c7ec737f59270c01f0d3c1376388f4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a83c7ec737f59270c01f0d3c1376388f4">next_index</a> (<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, 1+sizeof...(N)&gt; &amp;pos)</td></tr>
<tr class="memdesc:a83c7ec737f59270c01f0d3c1376388f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next index.  <a href="#a83c7ec737f59270c01f0d3c1376388f4">More...</a><br /></td></tr>
<tr class="separator:a83c7ec737f59270c01f0d3c1376388f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t M, std::size_t... N&gt;<br />
struct pre::multi&lt; T, M, N... &gt;</h3>

<p>Multi-dimensional array. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a501812ac2dd4831ad3137673019e0bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501812ac2dd4831ad3137673019e0bb6">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type. </p>

</div>
</div>
<a id="a2638f6b5363f4d50ed01a13c58b4a335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2638f6b5363f4d50ed01a13c58b4a335">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a2638f6b5363f4d50ed01a13c58b4a335">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference type. </p>

</div>
</div>
<a id="af5f1064d7fb7ffcb50e0ece561c8b465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f1064d7fb7ffcb50e0ece561c8b465">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef multi_value_type&lt;T, N...&gt;::type pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value type. </p>

</div>
</div>
<a id="ab63f4604a563d8afdfeac2726ed800d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63f4604a563d8afdfeac2726ed800d5">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&amp; pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab63f4604a563d8afdfeac2726ed800d5">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference. </p>

</div>
</div>
<a id="ab0f7146642a24f814a45ce1b23696945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f7146642a24f814a45ce1b23696945">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>* pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab0f7146642a24f814a45ce1b23696945">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer. </p>

</div>
</div>
<a id="a803086da400697511ed10a936fce4e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803086da400697511ed10a936fce4e0c">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>&amp; pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a803086da400697511ed10a936fce4e0c">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const reference. </p>

</div>
</div>
<a id="a75ee9eb1ab1d1bf7e588cfd948aa09c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ee9eb1ab1d1bf7e588cfd948aa09c5">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a>* pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a75ee9eb1ab1d1bf7e588cfd948aa09c5">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const pointer. </p>

</div>
</div>
<a id="a465816ad75a7c41ad5c0d4ee91cce7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465816ad75a7c41ad5c0d4ee91cce7a8">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab0f7146642a24f814a45ce1b23696945">pointer</a> pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator. </p>

</div>
</div>
<a id="a8876addc1c44d9e0fa693c9319cb4a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8876addc1c44d9e0fa693c9319cb4a9a">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a75ee9eb1ab1d1bf7e588cfd948aa09c5">const_pointer</a> pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator. </p>

</div>
</div>
<a id="aca7ba5bce5775012b2424ff3b3862ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7ba5bce5775012b2424ff3b3862ba6">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a>&gt; pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aca7ba5bce5775012b2424ff3b3862ba6">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator. </p>

</div>
</div>
<a id="aa0dc1428e3243e5b5bc315b266eacbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0dc1428e3243e5b5bc315b266eacbdb">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a>&gt; pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const reverse iterator. </p>

</div>
</div>
<a id="a520e4c8dd839df7db0d23e8e05665d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520e4c8dd839df7db0d23e8e05665d0a">&#9670;&nbsp;</a></span>entry_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a520e4c8dd839df7db0d23e8e05665d0a">entry_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bottom-level entry type. </p>

</div>
</div>
<a id="ad53309a7cc0b27c5596d5653c93001c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53309a7cc0b27c5596d5653c93001c3">&#9670;&nbsp;</a></span>flatten_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt;T, (M * ... * N)&gt; pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ad53309a7cc0b27c5596d5653c93001c3">flatten_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten type. </p>

</div>
</div>
<a id="ac7a2ce4993e0302f35657f8032044954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2ce4993e0302f35657f8032044954">&#9670;&nbsp;</a></span>initializer_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef multi_initializer_list&lt;T, M, N...&gt;::type pre::multi&lt; T, M, N... &gt;::<a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ac7a2ce4993e0302f35657f8032044954">initializer_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer list. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abfe8f353749b89b121703e467d7548e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe8f353749b89b121703e467d7548e3">&#9670;&nbsp;</a></span>multi() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pre::multi&lt; T, M, N... &gt;::multi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a0e1fb064f0742bd92c8f709cfbd918ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1fb064f0742bd92c8f709cfbd918ac">&#9670;&nbsp;</a></span>multi() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pre::multi&lt; T, M, N... &gt;::multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ac7a2ce4993e0302f35657f8032044954">initializer_list</a>&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a9fc6e659cc9d9e725a76a049017cfb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc6e659cc9d9e725a76a049017cfb05">&#9670;&nbsp;</a></span>multi() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pre::multi&lt; T, M, N... &gt;::multi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a520e4c8dd839df7db0d23e8e05665d0a">entry_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a4b10d9f06646250b7726681fc59831fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b10d9f06646250b7726681fc59831fd">&#9670;&nbsp;</a></span>multi() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pre::multi&lt; T, M, N... &gt;::multi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a520e4c8dd839df7db0d23e8e05665d0a">entry_type</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a679bf363295a4dae5293c95091a4cbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679bf363295a4dae5293c95091a4cbea">&#9670;&nbsp;</a></span>alignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t pre::multi&lt; T, M, N... &gt;::alignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array alignment, to promote vectorization by compiler. </p>

</div>
</div>
<a id="a8ba66d65c9fd47a3d40efcfb84475c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba66d65c9fd47a3d40efcfb84475c61">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a> pre::multi&lt; T, M, N... &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size. </p>

</div>
</div>
<a id="a159153438bb097bf694b32f8f5fe8518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159153438bb097bf694b32f8f5fe8518">&#9670;&nbsp;</a></span>total_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a> pre::multi&lt; T, M, N... &gt;::total_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total size. </p>

</div>
</div>
<a id="a2732b1c51e540d715443f95145197a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2732b1c51e540d715443f95145197a6d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a> pre::multi&lt; T, M, N... &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>

</div>
</div>
<a id="a49393003a0bad823ae399b5c4391fc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49393003a0bad823ae399b5c4391fc27">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a> pre::multi&lt; T, M, N... &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator, const variant. </p>

</div>
</div>
<a id="a58563e3b91d8b4e3edeb76b63f381705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58563e3b91d8b4e3edeb76b63f381705">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a> pre::multi&lt; T, M, N... &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator, force const variant. </p>

</div>
</div>
<a id="aa9dcb7ae084f7f4660c5cdb75483beb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dcb7ae084f7f4660c5cdb75483beb1">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a465816ad75a7c41ad5c0d4ee91cce7a8">iterator</a> pre::multi&lt; T, M, N... &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>

</div>
</div>
<a id="a6396198f5a13a065b034194a6551d4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6396198f5a13a065b034194a6551d4d0">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a> pre::multi&lt; T, M, N... &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator, const variant. </p>

</div>
</div>
<a id="ab7e351d274d24a1bf58be19ebf9e02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e351d274d24a1bf58be19ebf9e02ff">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a8876addc1c44d9e0fa693c9319cb4a9a">const_iterator</a> pre::multi&lt; T, M, N... &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator, force const variant. </p>

</div>
</div>
<a id="a45c0db9c5ff97f8765fe36501945a810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c0db9c5ff97f8765fe36501945a810">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aca7ba5bce5775012b2424ff3b3862ba6">reverse_iterator</a> pre::multi&lt; T, M, N... &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse begin iterator. </p>

</div>
</div>
<a id="a37044d19f01d2868a97d7061b44bf49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37044d19f01d2868a97d7061b44bf49a">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a> pre::multi&lt; T, M, N... &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse begin iterator, const variant. </p>

</div>
</div>
<a id="aaac3b2dc74b8cb16062d2cdef2d3b6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac3b2dc74b8cb16062d2cdef2d3b6e7">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a> pre::multi&lt; T, M, N... &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse begin iterator, force const variant. </p>

</div>
</div>
<a id="acaa492e0545621ee7338fa7f0829b7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa492e0545621ee7338fa7f0829b7ae">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aca7ba5bce5775012b2424ff3b3862ba6">reverse_iterator</a> pre::multi&lt; T, M, N... &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse end iterator. </p>

</div>
</div>
<a id="ae26bcf3273b5d69340769687eec35223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26bcf3273b5d69340769687eec35223">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a> pre::multi&lt; T, M, N... &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse end iterator, const variant. </p>

</div>
</div>
<a id="a7a3e462d5c79626fc6bbace95ab74c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3e462d5c79626fc6bbace95ab74c3f">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#aa0dc1428e3243e5b5bc315b266eacbdb">const_reverse_iterator</a> pre::multi&lt; T, M, N... &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse end iterator, force const variant. </p>

</div>
</div>
<a id="a3e135396ac5ae6006b9d09315891dea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e135396ac5ae6006b9d09315891dea4">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab63f4604a563d8afdfeac2726ed800d5">reference</a> pre::multi&lt; T, M, N... &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Front element. </p>

</div>
</div>
<a id="a40232e8d00bbe928a2ec6d499dac1229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40232e8d00bbe928a2ec6d499dac1229">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a803086da400697511ed10a936fce4e0c">const_reference</a> pre::multi&lt; T, M, N... &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Front element, const variant. </p>

</div>
</div>
<a id="a23bf1ac5a0124f406782e3835b7cd1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bf1ac5a0124f406782e3835b7cd1a8">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ab63f4604a563d8afdfeac2726ed800d5">reference</a> pre::multi&lt; T, M, N... &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Back element. </p>

</div>
</div>
<a id="a51281c5d66bd0cae5c1ad0438e632925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51281c5d66bd0cae5c1ad0438e632925">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a803086da400697511ed10a936fce4e0c">const_reference</a> pre::multi&lt; T, M, N... &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Back element, const variant. </p>

</div>
</div>
<a id="a75b81ffb41f5b63eb9b06b9fcc654601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b81ffb41f5b63eb9b06b9fcc654601">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr pre::multi&lt; T, M, N... &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index accessor. </p>

</div>
</div>
<a id="a7efc360706604ea98b6ab54451fe09f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efc360706604ea98b6ab54451fe09f4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr pre::multi&lt; T, M, N... &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index accessor, const variant. </p>

</div>
</div>
<a id="a60759291767b41b71ea7c35e05a3625a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60759291767b41b71ea7c35e05a3625a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename... Q&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr pre::multi&lt; T, M, N... &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q &amp;&amp;...&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiple-index accessor. </p>

</div>
</div>
<a id="aad82203e7f52a3c1cbcd11eaf505db86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad82203e7f52a3c1cbcd11eaf505db86">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename... Q&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr pre::multi&lt; T, M, N... &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q &amp;&amp;...&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiple-index accessor, const variant. </p>

</div>
</div>
<a id="a1d639e52ceed72b7b4d4e458c2222cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d639e52ceed72b7b4d4e458c2222cf8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P , std::size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr pre::multi&lt; T, M, N... &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, K &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi-index accessor. </p>

</div>
</div>
<a id="a53e95b30ce1940d39fc16d18b1bb5bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e95b30ce1940d39fc16d18b1bb5bab">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P , std::size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr pre::multi&lt; T, M, N... &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, K &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi-index accessor, const variant. </p>

</div>
</div>
<a id="a83c7ec737f59270c01f0d3c1376388f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c7ec737f59270c01f0d3c1376388f4">&#9670;&nbsp;</a></span>next_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void pre::multi&lt; T, M, N... &gt;::next_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, 1+sizeof...(N)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Next index. </p>

</div>
</div>
<a id="a32ad43bb6399b31acba33c9c6ced553d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad43bb6399b31acba33c9c6ced553d">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entrywise pre-increment. </p>

</div>
</div>
<a id="ad112a098e218e7433f9fecec0d8bf232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad112a098e218e7433f9fecec0d8bf232">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entrywise pre-decrement. </p>

</div>
</div>
<a id="a08aab964fe6914255eab4e8035b4fccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aab964fe6914255eab4e8035b4fccd">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> pre::multi&lt; T, M, N... &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entrywise post-increment. </p>

</div>
</div>
<a id="a981590fde9a01cc4c74c289324d9ff77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981590fde9a01cc4c74c289324d9ff77">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a> pre::multi&lt; T, M, N... &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entrywise post-decrement. </p>

</div>
</div>
<a id="a188a23b3ab26cbb01079bf53af8e52ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188a23b3ab26cbb01079bf53af8e52ea">&#9670;&nbsp;</a></span>foldl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> pre::multi&lt; T, M, N... &gt;::foldl </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-to-right fold. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\( k \gets 0 \)</li>
<li>\( x \gets v_k \)</li>
<li>While \( k + 1 &lt; M \):<ul>
<li>\( x \gets f(x, v_{k + 1}) \)</li>
<li>\( k \gets k + 1 \)</li>
</ul>
</li>
<li>Return \( x \) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aeb52191994d46cd5a0ab5244175823a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb52191994d46cd5a0ab5244175823a7">&#9670;&nbsp;</a></span>foldr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> pre::multi&lt; T, M, N... &gt;::foldr </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-to-left fold. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\( k \gets M - 1 \)</li>
<li>\( x \gets v_k \)</li>
<li>While \( k - 1 \ge 0 \):<ul>
<li>\( x \gets f(x, v_{k - 1}) \)</li>
<li>\( k \gets k - 1 \)</li>
</ul>
</li>
<li>Return \( x \) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad79756f599551fac82e04a35860a6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79756f599551fac82e04a35860a6783">&#9670;&nbsp;</a></span>foldl_accum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::foldl_accum </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-to-right accumulating fold. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\( k \gets 0 \)</li>
<li>While \( k + 1 &lt; M \):<ul>
<li>\( v_{k + 1} \gets f(v_{k + 1}, v_k) \)</li>
<li>\( k \gets k + 1 \) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a58d039d4ffbcb24cffbe0f27f3032385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d039d4ffbcb24cffbe0f27f3032385">&#9670;&nbsp;</a></span>foldr_accum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::foldr_accum </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-to-left accumulating fold. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\( k \gets M - 1 \)</li>
<li>While \( k - 1 \ge 0 \):<ul>
<li>\( v_{k - 1} \gets f(v_{k - 1}, v_k) \)</li>
<li>\( k \gets k - 1 \) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="af4385edf932732c377925fc5eb23979f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4385edf932732c377925fc5eb23979f">&#9670;&nbsp;</a></span>foldl_adjacent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::foldl_adjacent </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-to-right adjacent fold. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\( k \gets 0 \)</li>
<li>While \( k + 1 &lt; M \):<ul>
<li>\( v_k \gets f(v_k, v_{k + 1}) \)</li>
<li>\( k \gets k + 1 \) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a81b183a81df8b98e5ef7a33ed89b84d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b183a81df8b98e5ef7a33ed89b84d4">&#9670;&nbsp;</a></span>foldr_adjacent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::foldr_adjacent </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-to-left adjacent fold. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\( k \gets M - 1 \)</li>
<li>While \( k - 1 \ge 0 \):<ul>
<li>\( v_k \gets f(v_k, v_{k - 1}) \)</li>
<li>\( k \gets k - 1 \) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9b13901c56aca76ebd33c911703f523b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13901c56aca76ebd33c911703f523b">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> pre::multi&lt; T, M, N... &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum. </p>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <code>foldl(std::plus&lt;value_type&gt;())</code>. </dd></dl>

</div>
</div>
<a id="a50160c1334f60b2d2f6b53019d761933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50160c1334f60b2d2f6b53019d761933">&#9670;&nbsp;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> pre::multi&lt; T, M, N... &gt;::prod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Product. </p>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <code>foldl(std::multiplies&lt;value_type&gt;())</code>. </dd></dl>

</div>
</div>
<a id="a95a5610275707dc2f86815c3d36236e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a5610275707dc2f86815c3d36236e5">&#9670;&nbsp;</a></span>accum_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::accum_sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulating sum. </p>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <code>foldl_accum(std::plus&lt;value_type&gt;())</code>. </dd></dl>

</div>
</div>
<a id="a85d508d97634c224c7bcc9e879091538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d508d97634c224c7bcc9e879091538">&#9670;&nbsp;</a></span>adjacent_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::adjacent_difference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjacent difference. </p>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <code>foldr_adjacent(std::minus&lt;value_type&gt;())</code>. </dd></dl>

</div>
</div>
<a id="a49b6636d3db44a2646e4df3b99dbb5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b6636d3db44a2646e4df3b99dbb5d9">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill from entry. </p>

</div>
</div>
<a id="a6270ae7f3242486ebc69662fb3c200ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6270ae7f3242486ebc69662fb3c200ca">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&amp; pre::multi&lt; T, M, N... &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill from entry array. </p>

</div>
</div>
<a id="a2e52f9eabed46f22329193f1a0ddd333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e52f9eabed46f22329193f1a0ddd333">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#ad53309a7cc0b27c5596d5653c93001c3">flatten_type</a> pre::multi&lt; T, M, N... &gt;::flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flatten. </p>

</div>
</div>
<a id="a3dbd51275fdb1b2bd6d2351c957e7524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbd51275fdb1b2bd6d2351c957e7524">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;std::size_t... K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt;T, K...&gt; pre::multi&lt; T, M, N... &gt;::reshape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape. </p>

</div>
</div>
<a id="a8831dbe916ceba564d0dde71ba7e98e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8831dbe916ceba564d0dde71ba7e98e5">&#9670;&nbsp;</a></span>operator multi< U, K... >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename U , std::size_t... K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pre::multi&lt; T, M, N... &gt;::operator <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; U, K... &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast operator. </p>

</div>
</div>
<a id="a08023aeb008fd4e005568b3eb6212701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08023aeb008fd4e005568b3eb6212701">&#9670;&nbsp;</a></span>operator std::enable_if_t< B, const T & >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;bool B = (M == 1 &amp;&amp; (... &amp;&amp; (N == 1)))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pre::multi&lt; T, M, N... &gt;::operator std::enable_if_t&lt; B, const T &amp;&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast operator. </p>
<p>Allows implicit cast of 1-dimensional arrays to entry type. </p>

</div>
</div>
<a id="a4adee7bfe1ab6ec66686fab50a3bc608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adee7bfe1ab6ec66686fab50a3bc608">&#9670;&nbsp;</a></span>swizzle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P , std::size_t K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt;T, K, N...&gt; pre::multi&lt; T, M, N... &gt;::swizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; P, K &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swizzle. </p>

</div>
</div>
<a id="abf9719e812af35a389bc979701ef713d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9719e812af35a389bc979701ef713d">&#9670;&nbsp;</a></span>swizzle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename... Q&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt;T, 1 + sizeof...(Q), N...&gt; pre::multi&lt; T, M, N... &gt;::swizzle </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q &amp;&amp;...&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swizzle. </p>

</div>
</div>
<a id="ab89281349394784cc0eac396217a26b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89281349394784cc0eac396217a26b6">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pre::multi&lt; T, M, N... &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any entries true? </p>

</div>
</div>
<a id="a9607fd879b164cf2214c6046adea7ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9607fd879b164cf2214c6046adea7ae4">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pre::multi&lt; T, M, N... &gt;::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All entries true? </p>

</div>
</div>
<a id="a9c217c34eff2295ff2d13d1de9d32bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c217c34eff2295ff2d13d1de9d32bb6">&#9670;&nbsp;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;bool B = (sizeof...(N) == 0)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;B, <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a>&gt; pre::multi&lt; T, M, N... &gt;::argmin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of minimum element. </p>

</div>
</div>
<a id="af084e4e4da7eb38ab33706ef7b5cc25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af084e4e4da7eb38ab33706ef7b5cc25b">&#9670;&nbsp;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;bool B = (sizeof...(N) == 0)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;B, <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#a501812ac2dd4831ad3137673019e0bb6">size_type</a>&gt; pre::multi&lt; T, M, N... &gt;::argmax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of maximum element. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7ded58356a37341d5d0ed6bf7bc26462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ded58356a37341d5d0ed6bf7bc26462">&#9670;&nbsp;</a></span>operator>></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename C , typename Ctraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;C, Ctraits&gt;&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; C, Ctraits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; T, M, N... &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse from <code>std::basic_istream</code>. </p>
<p>Format is <code>[v0,v1,...]</code>. Sets <code>std::ios_base::failbit</code> on error. </p>

</div>
</div>
<a id="a9e1f5d9da2895e3540099e2a7f229d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1f5d9da2895e3540099e2a7f229d04">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<div class="memtemplate">
template&lt;typename C , typename Ctraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;C, Ctraits&gt;&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; C, Ctraits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#abfe8f353749b89b121703e467d7548e3">multi</a>&lt; T, M, N... &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write into <code>std::basic_ostream</code>. </p>
<p>Format is <code>[v0,v1,...]</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a51d622ef17619329fd1524c4cf6a6adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d622ef17619329fd1524c4cf6a6adf">&#9670;&nbsp;</a></span>v_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpre_1_1multi_3_01T_00_01M_00_01N_8_8_8_01_4.html#af5f1064d7fb7ffcb50e0ece561c8b465">value_type</a> pre::multi&lt; T, M, N... &gt;::v_[M] = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
