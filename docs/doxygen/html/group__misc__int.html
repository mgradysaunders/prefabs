<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>preform: Miscellaneous int</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<!--Broken...-->
<!--<script type="text/javascript" src="dynsections.js"></script>-->
<!--Load MathJax manually...-->
<!--cdn.mathjax.org shutting down April 30th, 2019
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">-->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
MathJax.Hub.Config({
  displayAlign: "left",
  displayIndent: "2em",
  TeX: {
    Macros: {
        real: ["\\operatorname{Re}"],
        imag: ["\\operatorname{Im}"],
        dual: ["\\operatorname{Du}"],
        symm: ["\\operatorname{Symm}"],
        skew: ["\\operatorname{Skew}"],
        erf: ["\\operatorname{erf}"],
        erfc: ["\\operatorname{erfc}"],
        normalize: ["\\operatorname{normalize}"],
        argmin: ["\\operatorname{argmin}"],
        argmax: ["\\operatorname{argmax}"]
    }
  }
});
</script>
<script type="text/javascript" src="DoxygenFix.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">preform
   </div>
   <div id="projectbrief">C++ header-only utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous int</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1sized__int.html">pre::sized_int&lt; Nbytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sized int type selector.  <a href="structpre_1_1sized__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpre_1_1sized__uint.html">pre::sized_uint&lt; Nbytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sized unsigned int type selector.  <a href="structpre_1_1sized__uint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabbfa09a957c41322ac62a1d09381ccae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabbfa09a957c41322ac62a1d09381ccae"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#gabbfa09a957c41322ac62a1d09381ccae">pre::gcd</a> (T a, T b)</td></tr>
<tr class="memdesc:gabbfa09a957c41322ac62a1d09381ccae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor.  <a href="group__misc__int.html#gabbfa09a957c41322ac62a1d09381ccae">More...</a><br /></td></tr>
<tr class="separator:gabbfa09a957c41322ac62a1d09381ccae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277bf51c93d7e5b5736d1c332759396b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga277bf51c93d7e5b5736d1c332759396b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga277bf51c93d7e5b5736d1c332759396b">pre::gcd_bezout</a> (T a, T b, T *x, T *y)</td></tr>
<tr class="memdesc:ga277bf51c93d7e5b5736d1c332759396b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor with Bezout coefficients.  <a href="group__misc__int.html#ga277bf51c93d7e5b5736d1c332759396b">More...</a><br /></td></tr>
<tr class="separator:ga277bf51c93d7e5b5736d1c332759396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6410a1f4eae37183dc590c39d2073604"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6410a1f4eae37183dc590c39d2073604"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga6410a1f4eae37183dc590c39d2073604">pre::lcm</a> (T a, T b)</td></tr>
<tr class="memdesc:ga6410a1f4eae37183dc590c39d2073604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple.  <a href="group__misc__int.html#ga6410a1f4eae37183dc590c39d2073604">More...</a><br /></td></tr>
<tr class="separator:ga6410a1f4eae37183dc590c39d2073604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562a3f3641b8ea9d6934bc4b738ed73f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga562a3f3641b8ea9d6934bc4b738ed73f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga562a3f3641b8ea9d6934bc4b738ed73f">pre::isodd</a> (T n)</td></tr>
<tr class="memdesc:ga562a3f3641b8ea9d6934bc4b738ed73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is odd?  <a href="group__misc__int.html#ga562a3f3641b8ea9d6934bc4b738ed73f">More...</a><br /></td></tr>
<tr class="separator:ga562a3f3641b8ea9d6934bc4b738ed73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e37f9d1b2b2604f955f3726a293f945"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4e37f9d1b2b2604f955f3726a293f945"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga4e37f9d1b2b2604f955f3726a293f945">pre::iseven</a> (T n)</td></tr>
<tr class="memdesc:ga4e37f9d1b2b2604f955f3726a293f945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is even?  <a href="group__misc__int.html#ga4e37f9d1b2b2604f955f3726a293f945">More...</a><br /></td></tr>
<tr class="separator:ga4e37f9d1b2b2604f955f3726a293f945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3913a296cca1ac5c63c2991786db75e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3913a296cca1ac5c63c2991786db75e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga3913a296cca1ac5c63c2991786db75e5">pre::ispow2</a> (T n)</td></tr>
<tr class="memdesc:ga3913a296cca1ac5c63c2991786db75e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is power of 2?  <a href="group__misc__int.html#ga3913a296cca1ac5c63c2991786db75e5">More...</a><br /></td></tr>
<tr class="separator:ga3913a296cca1ac5c63c2991786db75e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a477873d4c543f3df08bb5f9f0cd4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga72a477873d4c543f3df08bb5f9f0cd4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga72a477873d4c543f3df08bb5f9f0cd4e">pre::roundpow2</a> (T n)</td></tr>
<tr class="memdesc:ga72a477873d4c543f3df08bb5f9f0cd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to power of 2.  <a href="group__misc__int.html#ga72a477873d4c543f3df08bb5f9f0cd4e">More...</a><br /></td></tr>
<tr class="separator:ga72a477873d4c543f3df08bb5f9f0cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6826dfbaaddf5bbc2387d59058b8a87f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6826dfbaaddf5bbc2387d59058b8a87f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga6826dfbaaddf5bbc2387d59058b8a87f">pre::first1</a> (T n)</td></tr>
<tr class="memdesc:ga6826dfbaaddf5bbc2387d59058b8a87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first bit equal to 1.  <a href="group__misc__int.html#ga6826dfbaaddf5bbc2387d59058b8a87f">More...</a><br /></td></tr>
<tr class="separator:ga6826dfbaaddf5bbc2387d59058b8a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab6a1780b82e4f697028b355b1c3162"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2ab6a1780b82e4f697028b355b1c3162"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga2ab6a1780b82e4f697028b355b1c3162">pre::rotl</a> (T val, unsigned rot)</td></tr>
<tr class="memdesc:ga2ab6a1780b82e4f697028b355b1c3162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclical bit rotate left.  <a href="group__misc__int.html#ga2ab6a1780b82e4f697028b355b1c3162">More...</a><br /></td></tr>
<tr class="separator:ga2ab6a1780b82e4f697028b355b1c3162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54e5c2e71459908ef69a67b85aa1be9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab54e5c2e71459908ef69a67b85aa1be9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#gab54e5c2e71459908ef69a67b85aa1be9">pre::rotr</a> (T val, unsigned rot)</td></tr>
<tr class="memdesc:gab54e5c2e71459908ef69a67b85aa1be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclical bit rotate right.  <a href="group__misc__int.html#gab54e5c2e71459908ef69a67b85aa1be9">More...</a><br /></td></tr>
<tr class="separator:gab54e5c2e71459908ef69a67b85aa1be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b15cadb567e2d205f45841b47806dc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3b15cadb567e2d205f45841b47806dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga3b15cadb567e2d205f45841b47806dc4">pre::bit_swap</a> (T val, int pos0, int pos1)</td></tr>
<tr class="memdesc:ga3b15cadb567e2d205f45841b47806dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit swap.  <a href="group__misc__int.html#ga3b15cadb567e2d205f45841b47806dc4">More...</a><br /></td></tr>
<tr class="separator:ga3b15cadb567e2d205f45841b47806dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8c671c2aaf370e266878226dbdad8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabe8c671c2aaf370e266878226dbdad8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#gabe8c671c2aaf370e266878226dbdad8a">pre::bit_reverse</a> (T val)</td></tr>
<tr class="memdesc:gabe8c671c2aaf370e266878226dbdad8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit reverse.  <a href="group__misc__int.html#gabe8c671c2aaf370e266878226dbdad8a">More...</a><br /></td></tr>
<tr class="separator:gabe8c671c2aaf370e266878226dbdad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023d3a3fa210878a44c57f79559e5f02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga023d3a3fa210878a44c57f79559e5f02"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga023d3a3fa210878a44c57f79559e5f02">pre::bit_interleave</a> (T val0, T val1)</td></tr>
<tr class="memdesc:ga023d3a3fa210878a44c57f79559e5f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit interleave.  <a href="group__misc__int.html#ga023d3a3fa210878a44c57f79559e5f02">More...</a><br /></td></tr>
<tr class="separator:ga023d3a3fa210878a44c57f79559e5f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8089c20b09ff68f28f6a5e81fb11e08a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8089c20b09ff68f28f6a5e81fb11e08a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga8089c20b09ff68f28f6a5e81fb11e08a">pre::clamp</a> (T k, T n)</td></tr>
<tr class="memdesc:ga8089c20b09ff68f28f6a5e81fb11e08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp integer in range.  <a href="group__misc__int.html#ga8089c20b09ff68f28f6a5e81fb11e08a">More...</a><br /></td></tr>
<tr class="separator:ga8089c20b09ff68f28f6a5e81fb11e08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92844389d317e8439d438796c929496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad92844389d317e8439d438796c929496"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#gad92844389d317e8439d438796c929496">pre::repeat</a> (T k, T n)</td></tr>
<tr class="memdesc:gad92844389d317e8439d438796c929496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap integer in range.  <a href="group__misc__int.html#gad92844389d317e8439d438796c929496">More...</a><br /></td></tr>
<tr class="separator:gad92844389d317e8439d438796c929496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b224aebc7cb347991632e3116933878"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8b224aebc7cb347991632e3116933878"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga8b224aebc7cb347991632e3116933878">pre::mirror</a> (T k, T n)</td></tr>
<tr class="memdesc:ga8b224aebc7cb347991632e3116933878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap integer in range, mirror with each repeat.  <a href="group__misc__int.html#ga8b224aebc7cb347991632e3116933878">More...</a><br /></td></tr>
<tr class="separator:ga8b224aebc7cb347991632e3116933878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d82666041c3e1ee299f57a3921c0b73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d82666041c3e1ee299f57a3921c0b73"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga1d82666041c3e1ee299f57a3921c0b73">pre::lcg_seek</a> (T x, T a, T b, T n)</td></tr>
<tr class="memdesc:ga1d82666041c3e1ee299f57a3921c0b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear congruential generator seek.  <a href="group__misc__int.html#ga1d82666041c3e1ee299f57a3921c0b73">More...</a><br /></td></tr>
<tr class="separator:ga1d82666041c3e1ee299f57a3921c0b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83824eed29e91d58f5cfe08a040f2021"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga83824eed29e91d58f5cfe08a040f2021"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga83824eed29e91d58f5cfe08a040f2021">pre::lcg_distance</a> (T x, T a, T b, T xn)</td></tr>
<tr class="memdesc:ga83824eed29e91d58f5cfe08a040f2021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear congruential generator distance.  <a href="group__misc__int.html#ga83824eed29e91d58f5cfe08a040f2021">More...</a><br /></td></tr>
<tr class="separator:ga83824eed29e91d58f5cfe08a040f2021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d725e4806b86f8a0fc740843de60b56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d725e4806b86f8a0fc740843de60b56"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga3d725e4806b86f8a0fc740843de60b56">pre::cantor</a> (T x, T y)</td></tr>
<tr class="memdesc:ga3d725e4806b86f8a0fc740843de60b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantor pairing function.  <a href="group__misc__int.html#ga3d725e4806b86f8a0fc740843de60b56">More...</a><br /></td></tr>
<tr class="separator:ga3d725e4806b86f8a0fc740843de60b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecfb9b54625c44ec9c9b1135927c752"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:gaeecfb9b54625c44ec9c9b1135927c752"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#gaeecfb9b54625c44ec9c9b1135927c752">pre::cantor</a> (T x, T y, T z, Ts... ws)</td></tr>
<tr class="memdesc:gaeecfb9b54625c44ec9c9b1135927c752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantor tuple pairing function.  <a href="group__misc__int.html#gaeecfb9b54625c44ec9c9b1135927c752">More...</a><br /></td></tr>
<tr class="separator:gaeecfb9b54625c44ec9c9b1135927c752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7556e99a8f8a496719b67a0f8ce1ecfa"><td class="memTemplParams" colspan="2">template&lt;std::size_t B, typename T &gt; </td></tr>
<tr class="memitem:ga7556e99a8f8a496719b67a0f8ce1ecfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__misc__int.html#ga7556e99a8f8a496719b67a0f8ce1ecfa">pre::bayer_index</a> (T i, T j)</td></tr>
<tr class="memdesc:ga7556e99a8f8a496719b67a0f8ce1ecfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bayer index for ordered dithering.  <a href="group__misc__int.html#ga7556e99a8f8a496719b67a0f8ce1ecfa">More...</a><br /></td></tr>
<tr class="separator:ga7556e99a8f8a496719b67a0f8ce1ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><code>&lt;preform/misc_int.hpp&gt;</code></p>
<p><b>C++ version</b>: &gt;=C++14 </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabbfa09a957c41322ac62a1d09381ccae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbfa09a957c41322ac62a1d09381ccae">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::gcd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greatest common divisor. </p>

</div>
</div>
<a id="ga277bf51c93d7e5b5736d1c332759396b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga277bf51c93d7e5b5736d1c332759396b">&#9670;&nbsp;</a></span>gcd_bezout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::gcd_bezout </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greatest common divisor with Bezout coefficients. </p>

</div>
</div>
<a id="ga6410a1f4eae37183dc590c39d2073604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6410a1f4eae37183dc590c39d2073604">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::lcm </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Least common multiple. </p>

</div>
</div>
<a id="ga562a3f3641b8ea9d6934bc4b738ed73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562a3f3641b8ea9d6934bc4b738ed73f">&#9670;&nbsp;</a></span>isodd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, bool&gt; pre::isodd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is odd? </p>

</div>
</div>
<a id="ga4e37f9d1b2b2604f955f3726a293f945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e37f9d1b2b2604f955f3726a293f945">&#9670;&nbsp;</a></span>iseven()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, bool&gt; pre::iseven </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is even? </p>

</div>
</div>
<a id="ga3913a296cca1ac5c63c2991786db75e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3913a296cca1ac5c63c2991786db75e5">&#9670;&nbsp;</a></span>ispow2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, bool&gt; pre::ispow2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is power of 2? </p>

</div>
</div>
<a id="ga72a477873d4c543f3df08bb5f9f0cd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72a477873d4c543f3df08bb5f9f0cd4e">&#9670;&nbsp;</a></span>roundpow2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::roundpow2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round up to power of 2. </p>

</div>
</div>
<a id="ga6826dfbaaddf5bbc2387d59058b8a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6826dfbaaddf5bbc2387d59058b8a87f">&#9670;&nbsp;</a></span>first1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::first1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first bit equal to 1. </p>
<dl class="section note"><dt>Note</dt><dd>This is equivalent to the binary logarithm if the input integer is a positive power of 2.</dd>
<dd>
Uses <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"><code>__builtin_ctz</code></a> when compiling with GCC. </dd></dl>

</div>
</div>
<a id="ga2ab6a1780b82e4f697028b355b1c3162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ab6a1780b82e4f697028b355b1c3162">&#9670;&nbsp;</a></span>rotl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::rotl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cyclical bit rotate left. </p>

</div>
</div>
<a id="gab54e5c2e71459908ef69a67b85aa1be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54e5c2e71459908ef69a67b85aa1be9">&#9670;&nbsp;</a></span>rotr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::rotr </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cyclical bit rotate right. </p>

</div>
</div>
<a id="ga3b15cadb567e2d205f45841b47806dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b15cadb567e2d205f45841b47806dc4">&#9670;&nbsp;</a></span>bit_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::bit_swap </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit swap. </p>

</div>
</div>
<a id="gabe8c671c2aaf370e266878226dbdad8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8c671c2aaf370e266878226dbdad8a">&#9670;&nbsp;</a></span>bit_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::bit_reverse </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit reverse. </p>

</div>
</div>
<a id="ga023d3a3fa210878a44c57f79559e5f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023d3a3fa210878a44c57f79559e5f02">&#9670;&nbsp;</a></span>bit_interleave()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::bit_interleave </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit interleave. </p>
<p>Form an integer \( z \) from the bits of \( x \) and \( y \) such that</p><ul>
<li>bit \( k \) of \( x \) is bit \( 2k \) of \( z \),</li>
<li>bit \( k \) of \( y \) is bit \( 2k + 1 \) of \( z \).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If the input integer type has \( 2^n \) bits, the top \( 2^{n - 1} \) bits of the input integers do not appear in the output. </dd></dl>

</div>
</div>
<a id="ga8089c20b09ff68f28f6a5e81fb11e08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8089c20b09ff68f28f6a5e81fb11e08a">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamp integer in range. </p>
<ul>
<li>If \( n &gt; 0 \), clamp \( k \) to \( [0, n) \).</li>
<li>If \( n &lt; 0 \), clamp \( k \) to \( (n, 0] \). </li>
</ul>

</div>
</div>
<a id="gad92844389d317e8439d438796c929496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad92844389d317e8439d438796c929496">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::repeat </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap integer in range. </p>
<ul>
<li>If \( n &gt; 0 \), wrap \( k \) to \( [0, n) \).</li>
<li><p class="startli">If \( n &lt; 0 \), wrap \( k \) to \( (n, 0] \).</p>
<p class="formulaDsp">
\[ \begin{aligned} \operatorname{repeat}(k; n) &amp;= \operatorname{repeat}(k + mn; n) \\ -\operatorname{repeat}(k; n) &amp;= \operatorname{repeat}(-k; -n) \end{aligned} \]
</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For \( k &gt; 0 \), \( n &gt; 0 \), this operation is equivalent to \( k \% n \). </dd></dl>

</div>
</div>
<a id="ga8b224aebc7cb347991632e3116933878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b224aebc7cb347991632e3116933878">&#9670;&nbsp;</a></span>mirror()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::mirror </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap integer in range, mirror with each repeat. </p>
<ul>
<li>If \( n &gt; 0 \), wrap \( k \) to \( [0, n) \).</li>
<li><p class="startli">If \( n &lt; 0 \), wrap \( k \) to \( (n, 0] \).</p>
<p class="formulaDsp">
\[ \begin{aligned} \operatorname{mirror}(k; n) &amp;= \operatorname{mirror}(k + mn; n), \, m = 2\ell \\ \operatorname{mirror}(k; n) &amp;= n - 1 - \operatorname{mirror}(k + mn; n), \, m = 2\ell + 1 \\ -\operatorname{mirror}(k; n) &amp;= \operatorname{mirror}(-k; -n) \end{aligned} \]
</p>
 </li>
</ul>

</div>
</div>
<a id="ga1d82666041c3e1ee299f57a3921c0b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d82666041c3e1ee299f57a3921c0b73">&#9670;&nbsp;</a></span>lcg_seek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value, T&gt; pre::lcg_seek </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear congruential generator seek. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>State.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>State multiplier.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>State increment.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Step count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If \( a \% 4 = 1 \) and \( b \) is odd, such that the generator has a full period of \( 2^{m} \) where \( m \) is the bit depth of the unsigned integral type, then seeking by negative numbers works as expected. </dd></dl>

</div>
</div>
<a id="ga83824eed29e91d58f5cfe08a040f2021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83824eed29e91d58f5cfe08a040f2021">&#9670;&nbsp;</a></span>lcg_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_unsigned&lt;T&gt;::value, T&gt; pre::lcg_distance </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>xn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear congruential generator distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>State.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>State multiplier.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>State increment.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xn</td><td>Target state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Unless \( a \% 4 = 1 \) and \( b \) is odd, such that the generator has a full period of \( 2^{m} \) where \( m \) is the bit depth of the unsigned integral type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d725e4806b86f8a0fc740843de60b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d725e4806b86f8a0fc740843de60b56">&#9670;&nbsp;</a></span>cantor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::cantor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cantor pairing function. </p>
<p class="formulaDsp">
\[ \pi(x, y) = \frac{1}{2}(x + y)(x + y + 1) + y \]
</p>
 
</div>
</div>
<a id="gaeecfb9b54625c44ec9c9b1135927c752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecfb9b54625c44ec9c9b1135927c752">&#9670;&nbsp;</a></span>cantor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::cantor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cantor tuple pairing function. </p>
<p class="formulaDsp">
\[ \pi(x, y, z, \ldots) = \pi(\pi(x, y), z, \ldots) \]
</p>
 
</div>
</div>
<a id="ga7556e99a8f8a496719b67a0f8ce1ecfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7556e99a8f8a496719b67a0f8ce1ecfa">&#9670;&nbsp;</a></span>bayer_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t B, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_integral&lt;T&gt;::value, T&gt; pre::bayer_index </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bayer index for ordered dithering. </p>
<p>Let \( \mathbf{M} \in \mathbb{R}^{n,n} \) denote the Bayer index matrix for dimension \( n = 2^B \), where </p><p class="formulaDsp">
\[ M_{i,j} = \frac{1}{n^2} \operatorname{reverse}_{2B}( \operatorname{interleave}(\operatorname{xor}(j, i), i)) \]
</p>
<p> This routine calculates \( n^2 M_{i,j} \), which is always an integer. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
